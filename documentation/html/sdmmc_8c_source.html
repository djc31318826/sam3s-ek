<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAM3S Software Package: S:/projets/EK/SAM3S-EK/sam3s_project_trunk/libraries/memories/sdmmc/sdmmc.c Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">SAM3S Software Package 2.1</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_bcc78437aa20a9e08ae4ab86f04766f4.html">libraries</a>      </li>
      <li><a class="el" href="dir_9d11e3e6f6141c04ec0c0a3a1b06ca89.html">memories</a>      </li>
      <li><a class="el" href="dir_3b92451c508e4d3f05165c0663142380.html">sdmmc</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>sdmmc.c</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ----------------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment"> *         ATMEL Microcontroller Software Support</span>
<a name="l00003"></a>00003 <span class="comment"> * ----------------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2008, Atmel Corporation</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment"> * All rights reserved.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00009"></a>00009 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * - Redistributions of source code must retain the above copyright notice,</span>
<a name="l00012"></a>00012 <span class="comment"> * this list of conditions and the disclaimer below.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * Atmel&#39;s name may not be used to endorse or promote products derived from</span>
<a name="l00015"></a>00015 <span class="comment"> * this software without specific prior written permission.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR</span>
<a name="l00018"></a>00018 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00019"></a>00019 <span class="comment"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE</span>
<a name="l00020"></a>00020 <span class="comment"> * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00021"></a>00021 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00022"></a>00022 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<a name="l00023"></a>00023 <span class="comment"> * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00024"></a>00024 <span class="comment"> * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00025"></a>00025 <span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<a name="l00026"></a>00026 <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00027"></a>00027 <span class="comment"> * ----------------------------------------------------------------------------</span>
<a name="l00028"></a>00028 <span class="comment"> */</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">/** \addtogroup sdmmc_api</span>
<a name="l00031"></a>00031 <span class="comment"> *  @{</span>
<a name="l00032"></a>00032 <span class="comment"> */</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00035"></a>00035 <span class="comment"> *         Headers</span>
<a name="l00036"></a>00036 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="memories_8h.html">memories.h</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;stdbool.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00047"></a>00047 <span class="comment"> *         Global variables</span>
<a name="l00048"></a>00048 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00051"></a>00051 <span class="comment"> *         Local constants</span>
<a name="l00052"></a>00052 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">/** \addtogroup sdmmc_op_state SD/MMC operation states</span>
<a name="l00055"></a>00055 <span class="comment"> *      @{*/</span>
<a name="l00056"></a>00056 <span class="preprocessor">#define SD_STATE_IDLE        0</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_INIT        1</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_READY       2</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_READ     0x10</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_RD_RDY   0x11</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_RD_BSY   0x12</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_WRITE    0x20</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_WR_RDY   0x21</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_WR_BSY   0x22</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#define SD_STATE_BOOT     0x30</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="comment">/**     @}*/</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">/** \addtogroup sdmmc_status_bm SD/MMC Status register constants</span>
<a name="l00069"></a>00069 <span class="comment"> *      @{*/</span>
<a name="l00070"></a>00070 <span class="preprocessor">#define STATUS_APP_CMD          (1UL &lt;&lt; 5)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_SWITCH_ERROR     (1UL &lt;&lt; 7)</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_READY_FOR_DATA   (1UL &lt;&lt; 8)</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_IDLE             (0UL &lt;&lt; 9)</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_READY            (1UL &lt;&lt; 9)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_IDENT            (2UL &lt;&lt; 9)</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_STBY             (3UL &lt;&lt; 9)</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_TRAN             (4UL &lt;&lt; 9)</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_DATA             (5UL &lt;&lt; 9)</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_RCV              (6UL &lt;&lt; 9)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_PRG              (7UL &lt;&lt; 9)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_DIS              (8UL &lt;&lt; 9)</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_STATE            (0xFUL &lt;&lt; 9)</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ERASE_RESET       (1UL &lt;&lt; 13)</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_WP_ERASE_SKIP     (1UL &lt;&lt; 15)</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_CIDCSD_OVERWRITE  (1UL &lt;&lt; 16)</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_OVERRUN           (1UL &lt;&lt; 17)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_UNERRUN           (1UL &lt;&lt; 18)</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ERROR             (1UL &lt;&lt; 19)</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_CC_ERROR          (1UL &lt;&lt; 20)</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_CARD_ECC_FAILED   (1UL &lt;&lt; 21)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ILLEGAL_COMMAND   (1UL &lt;&lt; 22)</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_COM_CRC_ERROR     (1UL &lt;&lt; 23)</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_UN_LOCK_FAILED    (1UL &lt;&lt; 24)</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_CARD_IS_LOCKED    (1UL &lt;&lt; 25)</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_WP_VIOLATION      (1UL &lt;&lt; 26)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ERASE_PARAM       (1UL &lt;&lt; 27)</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ERASE_SEQ_ERROR   (1UL &lt;&lt; 28)</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_BLOCK_LEN_ERROR   (1UL &lt;&lt; 29)</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ADDRESS_MISALIGN  (1UL &lt;&lt; 30)</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ADDR_OUT_OR_RANGE (1UL &lt;&lt; 31)</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="preprocessor">#define STATUS_STOP ((uint32_t)( STATUS_CARD_IS_LOCKED \</span>
<a name="l00103"></a>00103 <span class="preprocessor">                        | STATUS_COM_CRC_ERROR \</span>
<a name="l00104"></a>00104 <span class="preprocessor">                        | STATUS_ILLEGAL_COMMAND \</span>
<a name="l00105"></a>00105 <span class="preprocessor">                        | STATUS_CC_ERROR \</span>
<a name="l00106"></a>00106 <span class="preprocessor">                        | STATUS_ERROR \</span>
<a name="l00107"></a>00107 <span class="preprocessor">                        | STATUS_STATE \</span>
<a name="l00108"></a>00108 <span class="preprocessor">                        | STATUS_READY_FOR_DATA ))</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="preprocessor">#define STATUS_WRITE ((uint32_t)( STATUS_ADDR_OUT_OR_RANGE \</span>
<a name="l00111"></a>00111 <span class="preprocessor">                        | STATUS_ADDRESS_MISALIGN \</span>
<a name="l00112"></a>00112 <span class="preprocessor">                        | STATUS_BLOCK_LEN_ERROR \</span>
<a name="l00113"></a>00113 <span class="preprocessor">                        | STATUS_WP_VIOLATION \</span>
<a name="l00114"></a>00114 <span class="preprocessor">                        | STATUS_CARD_IS_LOCKED \</span>
<a name="l00115"></a>00115 <span class="preprocessor">                        | STATUS_COM_CRC_ERROR \</span>
<a name="l00116"></a>00116 <span class="preprocessor">                        | STATUS_ILLEGAL_COMMAND \</span>
<a name="l00117"></a>00117 <span class="preprocessor">                        | STATUS_CC_ERROR \</span>
<a name="l00118"></a>00118 <span class="preprocessor">                        | STATUS_ERROR \</span>
<a name="l00119"></a>00119 <span class="preprocessor">                        | STATUS_ERASE_RESET \</span>
<a name="l00120"></a>00120 <span class="preprocessor">                        | STATUS_STATE \</span>
<a name="l00121"></a>00121 <span class="preprocessor">                        | STATUS_READY_FOR_DATA ))</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="preprocessor">#define STATUS_READ  ((uint32_t)( STATUS_ADDR_OUT_OR_RANGE \</span>
<a name="l00124"></a>00124 <span class="preprocessor">                        | STATUS_ADDRESS_MISALIGN \</span>
<a name="l00125"></a>00125 <span class="preprocessor">                        | STATUS_BLOCK_LEN_ERROR \</span>
<a name="l00126"></a>00126 <span class="preprocessor">                        | STATUS_CARD_IS_LOCKED \</span>
<a name="l00127"></a>00127 <span class="preprocessor">                        | STATUS_COM_CRC_ERROR \</span>
<a name="l00128"></a>00128 <span class="preprocessor">                        | STATUS_ILLEGAL_COMMAND \</span>
<a name="l00129"></a>00129 <span class="preprocessor">                        | STATUS_CARD_ECC_FAILED \</span>
<a name="l00130"></a>00130 <span class="preprocessor">                        | STATUS_CC_ERROR \</span>
<a name="l00131"></a>00131 <span class="preprocessor">                        | STATUS_ERROR \</span>
<a name="l00132"></a>00132 <span class="preprocessor">                        | STATUS_ERASE_RESET \</span>
<a name="l00133"></a>00133 <span class="preprocessor">                        | STATUS_STATE \</span>
<a name="l00134"></a>00134 <span class="preprocessor">                        | STATUS_READY_FOR_DATA ))</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="preprocessor">#define STATUS_SD_SWITCH ((uint32_t)( STATUS_ADDR_OUT_OR_RANGE \</span>
<a name="l00137"></a>00137 <span class="preprocessor">                            | STATUS_CARD_IS_LOCKED \</span>
<a name="l00138"></a>00138 <span class="preprocessor">                            | STATUS_COM_CRC_ERROR \</span>
<a name="l00139"></a>00139 <span class="preprocessor">                            | STATUS_ILLEGAL_COMMAND \</span>
<a name="l00140"></a>00140 <span class="preprocessor">                            | STATUS_CARD_ECC_FAILED \</span>
<a name="l00141"></a>00141 <span class="preprocessor">                            | STATUS_CC_ERROR \</span>
<a name="l00142"></a>00142 <span class="preprocessor">                            | STATUS_ERROR \</span>
<a name="l00143"></a>00143 <span class="preprocessor">                            | STATUS_UNERRUN \</span>
<a name="l00144"></a>00144 <span class="preprocessor">                            | STATUS_OVERRUN \</span>
<a name="l00145"></a>00145 <span class="preprocessor">                            </span><span class="comment">/*| STATUS_STATE*/</span>))
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="preprocessor">#define STATUS_MMC_SWITCH ((uint32_t)( STATUS_CARD_IS_LOCKED \</span>
<a name="l00148"></a>00148 <span class="preprocessor">                            | STATUS_COM_CRC_ERROR \</span>
<a name="l00149"></a>00149 <span class="preprocessor">                            | STATUS_ILLEGAL_COMMAND \</span>
<a name="l00150"></a>00150 <span class="preprocessor">                            | STATUS_CC_ERROR \</span>
<a name="l00151"></a>00151 <span class="preprocessor">                            | STATUS_ERROR \</span>
<a name="l00152"></a>00152 <span class="preprocessor">                            | STATUS_ERASE_RESET \</span>
<a name="l00153"></a>00153 <span class="preprocessor">                            </span><span class="comment">/*| STATUS_STATE*/</span> \
<a name="l00154"></a>00154                             <span class="comment">/*| STATUS_READY_FOR_DATA*/</span> \
<a name="l00155"></a>00155                             | STATUS_SWITCH_ERROR ))
<a name="l00156"></a>00156 <span class="comment">/**     @}*/</span>
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">/** \addtogroup sdio_status_bm SDIO Status definitions</span>
<a name="l00159"></a>00159 <span class="comment"> *      @{*/</span><span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">/** The CRC check of the previous command failed. */</span>
<a name="l00161"></a><a class="code" href="group__sdio__status__bm.html#ga64bc5966589d6582aefc8b1a49b66a36">00161</a> <span class="preprocessor">#define SDIO_COM_CRC_ERROR   (1UL &lt;&lt; 15)</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="comment">/** Command not legal for the card state. */</span>
<a name="l00163"></a><a class="code" href="group__sdio__status__bm.html#gab17eb59720f8fe3bb017a1356f099bb2">00163</a> <span class="preprocessor">#define SDIO_ILLEGAL_COMMAND (1UL &lt;&lt; 14)</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="comment">/** A general or an unknown error occurred during the operation. */</span>
<a name="l00165"></a><a class="code" href="group__sdio__status__bm.html#gaa7897661c13fc4e98d53d2beaeb91f30">00165</a> <span class="preprocessor">#define SDIO_R6_ERROR        (1UL &lt;&lt; 13)</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="comment">/** SDIO state (in R5) */</span>
<a name="l00167"></a><a class="code" href="group__sdio__status__bm.html#ga3e7dcf4ee6cff4bdc36b59091069b098">00167</a> <span class="preprocessor">#define SDIO_R5_STATE        (3UL &lt;&lt; 12)</span><span class="comment">/**&lt; SDIO R5 state mask */</span>
<a name="l00168"></a><a class="code" href="group__sdio__status__bm.html#ga652286ac435b366ab3c5227706970b7b">00168</a> <span class="preprocessor">#define SDIO_R5_STATE_DIS   (0UL &lt;&lt; 12) </span><span class="comment">/**&lt; Disabled */</span>
<a name="l00169"></a><a class="code" href="group__sdio__status__bm.html#ga6f5b98b5f084c9d7f80b93cf0306330f">00169</a> <span class="preprocessor">#define SDIO_R5_STATE_CMD   (1UL &lt;&lt; 12) </span><span class="comment">/**&lt; DAT lines free */</span>
<a name="l00170"></a><a class="code" href="group__sdio__status__bm.html#ga1df1d2febed11019cd1bc45357afa647">00170</a> <span class="preprocessor">#define SDIO_R5_STATE_TRN   (2UL &lt;&lt; 12) </span><span class="comment">/**&lt; Transfer */</span>
<a name="l00171"></a><a class="code" href="group__sdio__status__bm.html#ga8ec2d95847dd739c2bb1297180fa34ff">00171</a> <span class="preprocessor">#define SDIO_R5_STATE_RFU   (3UL &lt;&lt; 12) </span><span class="comment">/**&lt; Reserved */</span>
<a name="l00172"></a><a class="code" href="group__sdio__status__bm.html#ga7c5708b4b24ffb15f34ad63e06040abb">00172</a> <span class="preprocessor">#define SDIO_R5_ERROR        (1UL &lt;&lt; 11)</span><span class="comment">/**&lt; General error */</span>
<a name="l00173"></a><a class="code" href="group__sdio__status__bm.html#ga9e9aad9b20131227e802f1cf203c9b2c">00173</a> <span class="preprocessor">#define SDIO_R5_FUNC_NUM     (1UL &lt;&lt; 10)</span><span class="comment">/**&lt; Invalid function number */</span>
<a name="l00174"></a><a class="code" href="group__sdio__status__bm.html#gafbd57a452da7382292db7522e7086b49">00174</a> <span class="preprocessor">#define SDIO_R5_OUT_OF_RANGE (1UL &lt;&lt; 9) </span><span class="comment">/**&lt; Argument out of range */</span>
<a name="l00175"></a>00175 <span class="comment"></span>
<a name="l00176"></a>00176 <span class="comment">/** Status bits mask for SDIO R6 */</span>
<a name="l00177"></a><a class="code" href="group__sdio__status__bm.html#ga2600fb14c13c1be09cb6af9e934efc07">00177</a> <span class="preprocessor">#define STATUS_SDIO_R6  (SDIO_COM_CRC_ERROR \</span>
<a name="l00178"></a>00178 <span class="preprocessor">                         | SDIO_ILLEGAL_COMMAND \</span>
<a name="l00179"></a>00179 <span class="preprocessor">                         | SDIO_R6_ERROR)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="comment">/** Status bits mask for SDIO R5 */</span>
<a name="l00181"></a><a class="code" href="group__sdio__status__bm.html#ga73b5c422c2ff90724ac592289cfc524b">00181</a> <span class="preprocessor">#define STATUS_SDIO_R5  (0</span><span class="comment">/*SDIO_R5_STATE*/</span> \
<a name="l00182"></a>00182                          | SDIO_R5_ERROR \
<a name="l00183"></a>00183                          | SDIO_R5_FUNC_NUM \
<a name="l00184"></a>00184                          | SDIO_R5_OUT_OF_RANGE)
<a name="l00185"></a>00185 <span class="comment">/**     @}*/</span>
<a name="l00186"></a>00186 <span class="comment"></span>
<a name="l00187"></a>00187 <span class="comment">/** \addtogroup sdmmc_ocr_bm OCR Register definitions</span>
<a name="l00188"></a>00188 <span class="comment"> *      @{*/</span>
<a name="l00189"></a>00189 <span class="preprocessor">#define OCR_VDD_16_17          ((uint32_t)(1 &lt;&lt;  4))</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_17_18          ((uint32_t)(1 &lt;&lt;  5))</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_18_19          ((uint32_t)(1 &lt;&lt;  6))</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_19_20          ((uint32_t)(1 &lt;&lt;  7))</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_20_21          ((uint32_t)(1 &lt;&lt;  8))</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_21_22          ((uint32_t)(1 &lt;&lt;  9))</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_22_23          ((uint32_t)(1 &lt;&lt; 10))</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_23_24          ((uint32_t)(1 &lt;&lt; 11))</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_24_25          ((uint32_t)(1 &lt;&lt; 12))</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_25_26          ((uint32_t)(1 &lt;&lt; 13))</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_26_27          ((uint32_t)(1 &lt;&lt; 14))</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_27_28          ((uint32_t)(1 &lt;&lt; 15))</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_28_29          ((uint32_t)(1 &lt;&lt; 16))</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_29_30          ((uint32_t)(1 &lt;&lt; 17))</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_30_31          ((uint32_t)(1 &lt;&lt; 18))</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_31_32          ((uint32_t)(1 &lt;&lt; 19))</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_32_33          ((uint32_t)(1 &lt;&lt; 20))</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_33_34          ((uint32_t)(1 &lt;&lt; 21))</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_34_35          ((uint32_t)(1 &lt;&lt; 22))</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span><span class="preprocessor">#define OCR_VDD_35_36          ((uint32_t)(1 &lt;&lt; 23))</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>
<a name="l00210"></a>00210 <span class="preprocessor">#define SDMMC_HOST_VOLTAGE_RANGE     (OCR_VDD_27_28 +\</span>
<a name="l00211"></a>00211 <span class="preprocessor">                                      OCR_VDD_28_29 +\</span>
<a name="l00212"></a>00212 <span class="preprocessor">                                      OCR_VDD_29_30 +\</span>
<a name="l00213"></a>00213 <span class="preprocessor">                                      OCR_VDD_30_31 +\</span>
<a name="l00214"></a>00214 <span class="preprocessor">                                      OCR_VDD_31_32 +\</span>
<a name="l00215"></a>00215 <span class="preprocessor">                                      OCR_VDD_32_33)</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>
<a name="l00217"></a>00217 <span class="preprocessor">#define OCR_BIT2930            (3UL &lt;&lt; 29)</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span><span class="preprocessor">#define OCR_MMC_HIGH_DENSITY   (0x2UL &lt;&lt; 29)</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span><span class="preprocessor">#define OCR_MMC_HD             (0x2UL &lt;&lt; 29)</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>
<a name="l00221"></a>00221 <span class="preprocessor">#define OCR_SDIO_MP            (1UL &lt;&lt; 27)</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span><span class="preprocessor">#define OCR_SDIO_NF            (7UL &lt;&lt; 28)</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>
<a name="l00224"></a>00224 <span class="preprocessor">#define OCR_SD_CCS             (1UL &lt;&lt; 30)</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>
<a name="l00226"></a>00226 <span class="preprocessor">#define OCR_POWER_UP_BUSY      (1UL &lt;&lt; 31)</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="comment">/**     @}*/</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// Optional commands</span>
<a name="l00230"></a>00230 <span class="preprocessor">#define SD_ACMD6_SUPPORT        ((uint32_t)1 &lt;&lt; 0)</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span><span class="preprocessor">#define SD_ACMD13_SUPPORT       ((uint32_t)1 &lt;&lt; 1)</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="preprocessor">#define SD_ACMD41_SUPPORT       ((uint32_t)1 &lt;&lt; 2)</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="preprocessor">#define SD_ACMD51_SUPPORT       ((uint32_t)1 &lt;&lt; 3)</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#define SD_CMD16_SUPPORT        ((uint32_t)1 &lt;&lt; 8)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>
<a name="l00236"></a>00236 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00237"></a>00237 <span class="comment"> *         Macros</span>
<a name="l00238"></a>00238 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00239"></a>00239 <span class="comment"></span>
<a name="l00240"></a>00240 <span class="comment">/** Return SD/MMC card address */</span>
<a name="l00241"></a><a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">00241</a> <span class="preprocessor">#define CARD_ADDR(pSd)          (pSd-&gt;cardAddress)</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00243"></a>00243 <span class="comment">/** Return SD/MMC card block size (Default size now, 512B) */</span>
<a name="l00244"></a><a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">00244</a> <span class="preprocessor">#define BLOCK_SIZE(pSd)         (SDMMC_BLOCK_SIZE)</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00246"></a>00246 <span class="comment">/** Convert block address to SD/MMC command parameter */</span>
<a name="l00247"></a><a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">00247</a> <span class="preprocessor">#define SD_ADDRESS(pSd, address) \</span>
<a name="l00248"></a>00248 <span class="preprocessor">    ( ((pSd)-&gt;totalSize == 0xFFFFFFFF) ? \</span>
<a name="l00249"></a>00249 <span class="preprocessor">                            (address):((address) &lt;&lt; SDMMC_BLOCK_SIZE_SHIFT) )</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment">/** Check if SD Spec version 1.10 or later */</span>
<a name="l00252"></a><a class="code" href="group__sdmmc__api.html#gaf67ede43e9e32e6524e53499b3dc5a74">00252</a> <span class="preprocessor">#define SD_IsVer1_10(pSd) \</span>
<a name="l00253"></a>00253 <span class="preprocessor">    ( SD_SCR_SD_SPEC(pSd) &gt;= SD_SCR_SD_SPEC_1_10 )</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00255"></a>00255 <span class="comment">/** Check if SD card support HS mode (1.10 or later) */</span>
<a name="l00256"></a><a class="code" href="group__sdmmc__api.html#ga6d66d1883c2ee86470031e82b95a45b2">00256</a> <span class="preprocessor">#define SD_IsHsModeSupported(pSd)  \</span>
<a name="l00257"></a>00257 <span class="preprocessor">    ( SD_IsVer1_10(pSd)||(SD_CSD_STRUCTURE(pSd)&gt;=1) )</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00259"></a>00259 <span class="comment">/** Check if SD card support 4-bit mode (All SD card) */</span>
<a name="l00260"></a><a class="code" href="group__sdmmc__api.html#ga03e90d785edaf7e10bf23ff0d84a8185">00260</a> <span class="preprocessor">#define SD_IsBusModeSupported(pSd) (1)</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">/** Check if MMC Spec version 4 */</span>
<a name="l00263"></a><a class="code" href="group__sdmmc__api.html#ga07bc6ff131eea07308e69fcaa30213cf">00263</a> <span class="preprocessor">#define MMC_IsVer4(pSd)     ( SD_CSD_SPEC_VERS(pSd) &gt;= 4 )</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00265"></a>00265 <span class="comment">/** Check if MMC CSD structure is 1.2 (3.1 or later) */</span>
<a name="l00266"></a><a class="code" href="group__sdmmc__api.html#ga71c800949bd5b9f116f556152f4679ec">00266</a> <span class="preprocessor">#define MMC_IsCSDVer1_2(pSd) \</span>
<a name="l00267"></a>00267 <span class="preprocessor">    (  (SD_CSD_STRUCTURE(pSd)==2) \</span>
<a name="l00268"></a>00268 <span class="preprocessor">     ||(SD_CSD_STRUCTURE(pSd)&gt;2&amp;&amp;SD_EXTCSD_CSD_STRUCTURE(pSd)&gt;=2) )</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00270"></a>00270 <span class="comment">/** Check if MMC card support boot mode (4.3 or later) */</span>
<a name="l00271"></a><a class="code" href="group__sdmmc__api.html#ga652294ceb07834e06b2781fc7d3fad2a">00271</a> <span class="preprocessor">#define MMC_IsBootModeSupported(pSd) \</span>
<a name="l00272"></a>00272 <span class="preprocessor">    (  (MMC_IsVer4(pSd)&amp;&amp;(SD_CID_CBX(pSd)==0x01)  )</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00274"></a>00274 <span class="comment">/** Check if MMC card support 8-bit mode (4.0 or later) */</span>
<a name="l00275"></a><a class="code" href="group__sdmmc__api.html#ga5c22749c00124c228b021f326a9a5f9d">00275</a> <span class="preprocessor">#define MMC_IsBusModeSupported(pSd) (MMC_IsVer4(pSd))</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment">/** Check if MMC card support HS mode (4.0 or later) */</span>
<a name="l00278"></a><a class="code" href="group__sdmmc__api.html#ga09797c276041c74e4d68fcbb2f8de206">00278</a> <span class="preprocessor">#define MMC_IsHsModeSupported(pSd)  \</span>
<a name="l00279"></a>00279 <span class="preprocessor">    (MMC_IsCSDVer1_2(pSd)&amp;&amp;(SD_EXTCSD_CARD_TYPE(pSd)&amp;0x2))</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>
<a name="l00281"></a>00281 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00282"></a>00282 <span class="comment"> *         Local variables</span>
<a name="l00283"></a>00283 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00284"></a>00284 <span class="comment"></span>
<a name="l00285"></a>00285 <span class="comment">/** SD/MMC transfer rate unit codes (10K) list */</span>
<a name="l00286"></a>00286 <span class="keyword">static</span> <span class="keyword">const</span> uint32_t sdmmcTransUnits[7] = {
<a name="l00287"></a>00287     10, 100, 1000, 10000,
<a name="l00288"></a>00288     0, 0, 0
<a name="l00289"></a>00289 };
<a name="l00290"></a>00290 <span class="comment"></span>
<a name="l00291"></a>00291 <span class="comment">/** SD transfer multiplier factor codes (1/10) list */</span>
<a name="l00292"></a>00292 <span class="keyword">static</span> <span class="keyword">const</span> uint32_t sdTransMultipliers[16] = {
<a name="l00293"></a>00293     0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80
<a name="l00294"></a>00294 };
<a name="l00295"></a>00295 <span class="comment"></span>
<a name="l00296"></a>00296 <span class="comment">/** MMC transfer multiplier factor codes (1/10) list */</span>
<a name="l00297"></a>00297 <span class="keyword">static</span> <span class="keyword">const</span> uint32_t mmcTransMultipliers[16] = {
<a name="l00298"></a>00298     0, 10, 12, 13, 15, 20, 26, 30, 35, 40, 45, 52, 55, 60, 70, 80
<a name="l00299"></a>00299 };
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l00302"></a>00302 <span class="comment"> *         Local functions</span>
<a name="l00303"></a>00303 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l00304"></a>00304 <span class="comment"></span>
<a name="l00305"></a>00305 <span class="comment">/**</span>
<a name="l00306"></a>00306 <span class="comment"> * Delay some loop</span>
<a name="l00307"></a>00307 <span class="comment"> */</span>
<a name="l00308"></a>00308 <span class="keyword">static</span> <span class="keywordtype">void</span> Delay(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loop)
<a name="l00309"></a>00309 {
<a name="l00310"></a>00310     <span class="keywordflow">for</span>(;loop &gt; 0; loop --);
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">/**</span>
<a name="l00314"></a>00314 <span class="comment"> * Find SDIO ManfID, Fun0 tuple.</span>
<a name="l00315"></a>00315 <span class="comment"> * \param pSd         Pointer to \ref SdCard instance.</span>
<a name="l00316"></a>00316 <span class="comment"> * \param address     Search area start address.</span>
<a name="l00317"></a>00317 <span class="comment"> * \param size        Search area size.</span>
<a name="l00318"></a>00318 <span class="comment"> * \param pAddrManfID Pointer to ManfID address value buffer.</span>
<a name="l00319"></a>00319 <span class="comment"> * \param pAddrFunc0  Pointer to Func0 address value buffer.</span>
<a name="l00320"></a>00320 <span class="comment"> */</span>
<a name="l00321"></a>00321 <span class="keyword">static</span> uint8_t SdioFindTuples(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00322"></a>00322                               uint32_t address, uint32_t size,
<a name="l00323"></a>00323                               uint32_t *pAddrManfID,
<a name="l00324"></a>00324                               uint32_t *pAddrFunc0)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     uint8_t error, tmp[3];
<a name="l00327"></a>00327     uint32_t addr = address;
<a name="l00328"></a>00328     uint8_t  flagFound = 0; <span class="comment">/* 1:Manf, 2:Func0 */</span>
<a name="l00329"></a>00329     uint32_t addManfID = 0, addFunc0 = 0;
<a name="l00330"></a>00330     <span class="keywordflow">for</span>(;flagFound != 3;) {
<a name="l00331"></a>00331         error = <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, addr, tmp, 3);
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (error) {
<a name="l00333"></a>00333             TRACE_ERROR(<span class="stringliteral">&quot;SdioFindTuples.RdDirect: %u\n\r&quot;</span>, error);
<a name="l00334"></a>00334             <span class="keywordflow">return</span> error;
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336         <span class="comment">/* End */</span>
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (tmp[0] == <a class="code" href="group__sdio__meta__def.html#gab55b15a6e3e612bbf7acf72c959acf83">CISTPL_END</a>) <span class="keywordflow">break</span>;
<a name="l00338"></a>00338         <span class="comment">/* ManfID */</span>
<a name="l00339"></a>00339         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tmp[0] == <a class="code" href="group__sdio__meta__def.html#ga254d188fdc3d26e69e7a9cd16801bbb0">CISTPL_MANFID</a>) {
<a name="l00340"></a>00340             flagFound |= 1; addManfID = addr;
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342         <span class="comment">/* Func0 */</span>
<a name="l00343"></a>00343         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tmp[0] == <a class="code" href="group__sdio__meta__def.html#ga99af349641e81e3aadae8c3d734bb411">CISTPL_FUNCE</a> &amp;&amp; tmp[2] == 0x00) {
<a name="l00344"></a>00344             flagFound |= 2; addFunc0 = addr;
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346         <span class="comment">/* Tuple error ? */</span>
<a name="l00347"></a>00347         <span class="keywordflow">if</span> (tmp[1] == 0) <span class="keywordflow">break</span>;
<a name="l00348"></a>00348         <span class="comment">/* Next address */</span>
<a name="l00349"></a>00349         addr += (tmp[1] + 2);
<a name="l00350"></a>00350         <span class="keywordflow">if</span> (addr &gt; (address + size)) <span class="keywordflow">break</span>;
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="keywordflow">if</span> (pAddrManfID) *pAddrManfID = addManfID;
<a name="l00353"></a>00353     <span class="keywordflow">if</span> (pAddrFunc0)  *pAddrFunc0  = addFunc0;
<a name="l00354"></a>00354     <span class="keywordflow">return</span> 0;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 <span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">/**</span>
<a name="l00358"></a>00358 <span class="comment"> * \brief Decode Trans Speed Value</span>
<a name="l00359"></a>00359 <span class="comment"> * \param code The trans speed code value.</span>
<a name="l00360"></a>00360 <span class="comment"> * \param unitCodes  Unit list in 10K, 0 as unused value.</span>
<a name="l00361"></a>00361 <span class="comment"> * \param multiCodes Multiplier list in 1/10, index 1 ~ 15 is valid.</span>
<a name="l00362"></a>00362 <span class="comment"> */</span>
<a name="l00363"></a>00363 <span class="keyword">static</span> uint32_t SdmmcDecodeTransSpeed(uint32_t code,
<a name="l00364"></a>00364                                       <span class="keyword">const</span> uint32_t *unitCodes,
<a name="l00365"></a>00365                                       <span class="keyword">const</span> uint32_t *multiCodes)
<a name="l00366"></a>00366 {
<a name="l00367"></a>00367     uint32_t speed;
<a name="l00368"></a>00368     uint8_t unitI, mulI;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370     <span class="comment">/* Unit code is valid ? */</span>
<a name="l00371"></a>00371     unitI = (code &amp; 0x7);
<a name="l00372"></a>00372     <span class="keywordflow">if</span> (unitCodes[unitI] == 0) <span class="keywordflow">return</span> 0;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <span class="comment">/* Multi code is valid ? */</span>
<a name="l00375"></a>00375     mulI = (code &gt;&gt; 3) &amp; 0xF;
<a name="l00376"></a>00376     <span class="keywordflow">if</span> (multiCodes[mulI] == 0) <span class="keywordflow">return</span> 0;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     speed = unitCodes[unitI] * multiCodes[mulI];
<a name="l00379"></a>00379     <span class="keywordflow">return</span> speed;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Pon(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga213c56e075e9bc06b0f20661a22b1bb1">SdmmcPowerOn</a>(pSd, NULL);
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd0(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint8_t arg)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gad0f5cb1fd760023c4d477f37f4c53360">SdmmcCmd0</a>(pSd, arg, NULL);
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd1(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint8_t* pHd)
<a name="l00393"></a>00393 {
<a name="l00394"></a>00394     uint8_t error;
<a name="l00395"></a>00395     uint32_t arg;
<a name="l00396"></a>00396     arg = SDMMC_HOST_VOLTAGE_RANGE | OCR_MMC_HD;
<a name="l00397"></a>00397     error = <a class="code" href="group__sdmmc__hal.html#ga592456ea308002a94b94dbb7f9bf9fa6">MmcCmd1</a>(pSd, &amp;arg, NULL);
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span> error;
<a name="l00399"></a>00399     <span class="keywordflow">if</span> (arg &amp; OCR_POWER_UP_BUSY) {
<a name="l00400"></a>00400         *pHd = 0;
<a name="l00401"></a>00401         <span class="keywordflow">if</span> ((arg &amp; OCR_BIT2930) == OCR_MMC_HIGH_DENSITY) {
<a name="l00402"></a>00402             *pHd = 1;
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 0;
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="keywordflow">return</span> SDMMC_ERROR_NOT_INITIALIZED;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd2(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga3d74d93860055b1dde1bee163df426bc">SdmmcCmd2</a>(pSd, pSd-&gt;<a class="code" href="struct_sd_card.html#a67164158219a672d9b784023befe962b">cid</a>, NULL);
<a name="l00412"></a>00412 }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="keyword">static</span> uint8_t Cmd3(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00415"></a>00415 {
<a name="l00416"></a>00416     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> == <a class="code" href="group__sdmmc__cardtype.html#ga1df56d102459c52ef22d4e4f2d0abaef">CARD_MMC</a> || pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> == <a class="code" href="group__sdmmc__cardtype.html#ga37c39c77a2025af2b22440dcb3712c0a">CARD_MMCHD</a>) {
<a name="l00417"></a>00417         uint8_t error = <a class="code" href="group__sdmmc__hal.html#ga0e0f27217daca00b84c2fdf494036e13">MmcCmd3</a>(pSd, 1, NULL);
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (!error) pSd-&gt;<a class="code" href="struct_sd_card.html#a922af00ff450d07074262014f01429a0">cardAddress</a> = 1;
<a name="l00419"></a>00419         <span class="keywordflow">return</span> error;
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421     <span class="keywordflow">else</span> {
<a name="l00422"></a>00422         uint8_t error;
<a name="l00423"></a>00423         uint32_t addr;
<a name="l00424"></a>00424         error = <a class="code" href="group__sdmmc__hal.html#gacbf9f1d65da462b4455711ada44cf2db">SdCmd3</a>(pSd, &amp;addr, NULL);
<a name="l00425"></a>00425         pSd-&gt;<a class="code" href="struct_sd_card.html#a922af00ff450d07074262014f01429a0">cardAddress</a> = (addr &gt;&gt; 16);
<a name="l00426"></a>00426         <span class="keywordflow">return</span> error;
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="keyword">static</span> uint8_t Cmd5(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t *pIo)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gad60a0d22c2e18373670d1d75b7642548">SdioCmd5</a>(pSd, pIo, NULL);
<a name="l00433"></a>00433 }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd7(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint16_t address)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga0f827e753360028931042c3e50bb7ae2">SdmmcCmd7</a>(pSd, address, NULL);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd9(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00441"></a>00441 {
<a name="l00442"></a>00442     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga1737b966870101b2a4137c9a8df6813c">SdmmcCmd9</a>(pSd, <a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">CARD_ADDR</a>(pSd), pSd-&gt;<a class="code" href="struct_sd_card.html#ac4754276c96ab4d9a7ca9757efd4cf37">csd</a>, NULL);
<a name="l00443"></a>00443 }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keyword">static</span> uint8_t Cmd12(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t *pStatus)
<a name="l00446"></a>00446 {
<a name="l00447"></a>00447     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gacf02fc9ccaa662051230f30d49bd9a47">SdmmcCmd12</a>(pSd, pStatus, NULL);
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="keyword">static</span> uint8_t Cmd13(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t *pStatus)
<a name="l00451"></a>00451 {
<a name="l00452"></a>00452     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga091a0035622dab61f305abd8f07a766a">SdmmcCmd13</a>(pSd, <a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">CARD_ADDR</a>(pSd), pStatus, NULL);
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd16(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint16_t blkLen)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gad18b1ed631e2fe2a6709b197c7a72e29">SdmmcCmd16</a>(pSd, blkLen, NULL);
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd17(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00461"></a>00461                             uint8_t *pData,
<a name="l00462"></a>00462                             uint32_t address,
<a name="l00463"></a>00463                             uint32_t *pStatus)
<a name="l00464"></a>00464 {
<a name="l00465"></a>00465     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gac6832c4a806e018133a189a094eee001">SdmmcCmd17</a>(pSd, <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), pData, address, pStatus, NULL);
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd18(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00469"></a>00469                             uint16_t nbBlock,
<a name="l00470"></a>00470                             uint8_t *pData,
<a name="l00471"></a>00471                             uint32_t address,
<a name="l00472"></a>00472                             uint32_t *pStatus)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga1995aa6a017bf8cfd6c0d2d4b4f16338">SdmmcCmd18</a>(pSd,
<a name="l00475"></a>00475                       <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), nbBlock,
<a name="l00476"></a>00476                       pData, address,
<a name="l00477"></a>00477                       pStatus, NULL);
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd24(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00481"></a>00481                             uint8_t *pData,
<a name="l00482"></a>00482                             uint32_t address,
<a name="l00483"></a>00483                             uint32_t *pStatus)
<a name="l00484"></a>00484 {
<a name="l00485"></a>00485     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga2897be35a26cdce08ab9a987600918b5">SdmmcCmd24</a>(pSd, <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), pData, address, pStatus, NULL);
<a name="l00486"></a>00486 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd25(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00489"></a>00489                             uint16_t nbBlock,
<a name="l00490"></a>00490                             uint8_t *pData,
<a name="l00491"></a>00491                             uint32_t address,
<a name="l00492"></a>00492                             uint32_t *pStatus)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gab2e2124fddce66511db364fee5591a50">SdmmcCmd25</a>(pSd,
<a name="l00495"></a>00495                       <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), nbBlock,
<a name="l00496"></a>00496                       pData, address,
<a name="l00497"></a>00497                       pStatus, NULL);
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd52(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00501"></a>00501                             uint8_t wrFlag,
<a name="l00502"></a>00502                             uint8_t funcNb,
<a name="l00503"></a>00503                             uint8_t rdAfterWr,
<a name="l00504"></a>00504                             uint32_t addr,
<a name="l00505"></a>00505                             uint32_t *pIoData)
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507     SdioCmd52Arg *pArg52 = (SdioCmd52Arg*)pIoData;
<a name="l00508"></a>00508     pArg52-&gt;rwFlag = wrFlag;
<a name="l00509"></a>00509     pArg52-&gt;functionNum = funcNb;
<a name="l00510"></a>00510     pArg52-&gt;rawFlag = rdAfterWr;
<a name="l00511"></a>00511     pArg52-&gt;regAddress = addr;
<a name="l00512"></a>00512     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga187353286019992763b7e938bc794e77">SdioCmd52</a>(pSd, pIoData, NULL);
<a name="l00513"></a>00513 }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t Cmd53(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00516"></a>00516                             uint8_t wrFlag,
<a name="l00517"></a>00517                             uint8_t funcNb,
<a name="l00518"></a>00518                             uint8_t blockMode,
<a name="l00519"></a>00519                             uint8_t incAddr,
<a name="l00520"></a>00520                             uint32_t addr,
<a name="l00521"></a>00521                             uint8_t *pIoData,
<a name="l00522"></a>00522                             uint16_t len,
<a name="l00523"></a>00523                             uint32_t *pArgResp,
<a name="l00524"></a>00524                             <a class="code" href="group__sdmmc__hal.html#gae854df62b67725efa2e97f8ea868abd2">SdmmcCallback</a> fCallback,
<a name="l00525"></a>00525                             <span class="keywordtype">void</span>* pCbArg)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527     uint8_t  error;
<a name="l00528"></a>00528     SdioCmd53Arg* pArg53;
<a name="l00529"></a>00529     pArg53 = (SdioCmd53Arg*)pArgResp;
<a name="l00530"></a>00530     pArg53-&gt;rwFlag = wrFlag;
<a name="l00531"></a>00531     pArg53-&gt;functionNum = funcNb;
<a name="l00532"></a>00532     pArg53-&gt;blockMode = blockMode;
<a name="l00533"></a>00533     pArg53-&gt;opCode = incAddr;
<a name="l00534"></a>00534     pArg53-&gt;regAddress = addr;
<a name="l00535"></a>00535     pArg53-&gt;count = len;
<a name="l00536"></a>00536     error = <a class="code" href="group__sdmmc__hal.html#ga6446d81e02955c88d0e515a50a5dc29c">SdioCmd53</a>(pSd, pArgResp, pIoData, len, fCallback, pCbArg);
<a name="l00537"></a>00537     <span class="keywordflow">return</span> error;
<a name="l00538"></a>00538 }
<a name="l00539"></a>00539 <span class="comment"></span>
<a name="l00540"></a>00540 <span class="comment">/**</span>
<a name="l00541"></a>00541 <span class="comment"> * Defines the data bus width (00=1bit or 10=4 bits bus) to be used for data</span>
<a name="l00542"></a>00542 <span class="comment"> * transfer.</span>
<a name="l00543"></a>00543 <span class="comment"> * The allowed data bus widths are given in SCR register.</span>
<a name="l00544"></a>00544 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l00545"></a>00545 <span class="comment"> * \param busWidth  Bus width in bits.</span>
<a name="l00546"></a>00546 <span class="comment"> * \return the command transfer result (see SendCommand).</span>
<a name="l00547"></a>00547 <span class="comment"> */</span>
<a name="l00548"></a>00548 <span class="keyword">static</span> uint8_t Acmd6(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint8_t busWidth)
<a name="l00549"></a>00549 {
<a name="l00550"></a>00550     uint8_t error;
<a name="l00551"></a>00551     uint32_t arg;
<a name="l00552"></a>00552     error = <a class="code" href="group__sdmmc__hal.html#ga94e0cb187ace97a9d3441717af62bdcd">SdmmcCmd55</a>(pSd, <a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">CARD_ADDR</a>(pSd), NULL);
<a name="l00553"></a>00553     <span class="keywordflow">if</span> (error) {
<a name="l00554"></a>00554         TRACE_ERROR(<span class="stringliteral">&quot;Acmd6.cmd55:%d\n\r&quot;</span>, error);
<a name="l00555"></a>00555         <span class="keywordflow">return</span> error;
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557     arg = (busWidth == SDMMC_BUS_4_BIT)
<a name="l00558"></a>00558         ? SD_STAT_DATA_BUS_WIDTH_4BIT : SD_STAT_DATA_BUS_WIDTH_1BIT;
<a name="l00559"></a>00559     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gaf5230e91b05d330fa52a67b3934ac745">SdAcmd6</a>(pSd, arg, NULL, NULL);
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">/**</span>
<a name="l00563"></a>00563 <span class="comment"> * The SD Status contains status bits that are related to the SD memory Card</span>
<a name="l00564"></a>00564 <span class="comment"> * proprietary features and may be used for future application-specific usage.</span>
<a name="l00565"></a>00565 <span class="comment"> * Can be sent to a card only in &#39;tran_state&#39;.</span>
<a name="l00566"></a>00566 <span class="comment"> */</span>
<a name="l00567"></a>00567 <span class="keyword">static</span> uint8_t Acmd13(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t *pSdSTAT)
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569     uint8_t error;
<a name="l00570"></a>00570     error = <a class="code" href="group__sdmmc__hal.html#ga94e0cb187ace97a9d3441717af62bdcd">SdmmcCmd55</a>(pSd, <a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">CARD_ADDR</a>(pSd), NULL);
<a name="l00571"></a>00571     <span class="keywordflow">if</span> (error) {
<a name="l00572"></a>00572         TRACE_ERROR(<span class="stringliteral">&quot;Acmd13.cmd55:%d\n\r&quot;</span>, error);
<a name="l00573"></a>00573         <span class="keywordflow">return</span> error;
<a name="l00574"></a>00574     }
<a name="l00575"></a>00575     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#gac47924beba774dee583ee3d85afbe29a">SdAcmd13</a>(pSd, pSdSTAT, NULL);
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 <span class="comment"></span>
<a name="l00578"></a>00578 <span class="comment">/**</span>
<a name="l00579"></a>00579 <span class="comment"> * Asks to all cards to send their operations conditions.</span>
<a name="l00580"></a>00580 <span class="comment"> * Returns the command transfer result (see SendCommand).</span>
<a name="l00581"></a>00581 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l00582"></a>00582 <span class="comment"> * \param hcs  Shall be true if Host support High capacity.</span>
<a name="l00583"></a>00583 <span class="comment"> * \param pCCS  Set the pointed flag to 1 if hcs != 0 and SD OCR CCS flag is set.</span>
<a name="l00584"></a>00584 <span class="comment"> */</span>
<a name="l00585"></a>00585 <span class="keyword">static</span> uint8_t Acmd41(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint8_t hcs, uint8_t *pCCS)
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587     uint8_t error;
<a name="l00588"></a>00588     uint32_t arg;
<a name="l00589"></a>00589     <span class="keywordflow">do</span> {
<a name="l00590"></a>00590         error = <a class="code" href="group__sdmmc__hal.html#ga94e0cb187ace97a9d3441717af62bdcd">SdmmcCmd55</a>(pSd, 0, NULL);
<a name="l00591"></a>00591         <span class="keywordflow">if</span> (error) {
<a name="l00592"></a>00592             TRACE_ERROR(<span class="stringliteral">&quot;Acmd41.cmd55:%d\n\r&quot;</span>, error);
<a name="l00593"></a>00593             <span class="keywordflow">return</span> error;
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595         arg = SDMMC_HOST_VOLTAGE_RANGE;
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (hcs) arg |= OCR_SD_CCS;
<a name="l00597"></a>00597         error = <a class="code" href="group__sdmmc__hal.html#ga51a5d22ba387333185492817c7d11d41">SdAcmd41</a>(pSd, &amp;arg, NULL);
<a name="l00598"></a>00598         <span class="keywordflow">if</span> (error) {
<a name="l00599"></a>00599             TRACE_ERROR(<span class="stringliteral">&quot;Acmd41.cmd41:%d\n\r&quot;</span>, error);
<a name="l00600"></a>00600             <span class="keywordflow">return</span> error;
<a name="l00601"></a>00601         }
<a name="l00602"></a>00602         *pCCS = ((arg &amp; OCR_SD_CCS)!=0);
<a name="l00603"></a>00603     } <span class="keywordflow">while</span> ((arg &amp; OCR_POWER_UP_BUSY) != OCR_POWER_UP_BUSY);
<a name="l00604"></a>00604     <span class="keywordflow">return</span> 0;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">/**</span>
<a name="l00608"></a>00608 <span class="comment"> * SD Card Configuration Register (SCR) provides information on the SD Memory</span>
<a name="l00609"></a>00609 <span class="comment"> * Card&#39;s special features that were configured into the given card. The size</span>
<a name="l00610"></a>00610 <span class="comment"> * of SCR register is 64 bits.</span>
<a name="l00611"></a>00611 <span class="comment"> */</span>
<a name="l00612"></a>00612 <span class="keyword">static</span> uint8_t Acmd51(<a class="code" href="struct_sd_card.html">SdCard</a>* pSd, uint32_t *pSCR)
<a name="l00613"></a>00613 {
<a name="l00614"></a>00614     uint8_t error;
<a name="l00615"></a>00615     error = <a class="code" href="group__sdmmc__hal.html#ga94e0cb187ace97a9d3441717af62bdcd">SdmmcCmd55</a>(pSd, <a class="code" href="group__sdmmc__api.html#gacf8005eb46610244c50491b58777a5ae">CARD_ADDR</a>(pSd), NULL);
<a name="l00616"></a>00616     <span class="keywordflow">if</span> (error) {
<a name="l00617"></a>00617         TRACE_ERROR(<span class="stringliteral">&quot;Acmd51.cmd55:%d\n\r&quot;</span>, error);
<a name="l00618"></a>00618         <span class="keywordflow">return</span> error;
<a name="l00619"></a>00619     }
<a name="l00620"></a>00620     <span class="keywordflow">return</span> <a class="code" href="group__sdmmc__hal.html#ga16bb4424d8da1979b972dee9622bbbcc">SdAcmd51</a>(pSd, pSCR, NULL);
<a name="l00621"></a>00621 }
<a name="l00622"></a>00622 <span class="comment"></span>
<a name="l00623"></a>00623 <span class="comment">/**</span>
<a name="l00624"></a>00624 <span class="comment"> * Try SW Reset several times (CMD0 with ARG 0)</span>
<a name="l00625"></a>00625 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l00626"></a>00626 <span class="comment"> * \param retry    Retry times.</span>
<a name="l00627"></a>00627 <span class="comment"> * \return 0 or MCI error code.</span>
<a name="l00628"></a>00628 <span class="comment"> */</span>
<a name="l00629"></a>00629 <span class="keyword">static</span> uint8_t SwReset(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t retry)
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631     uint32_t i;
<a name="l00632"></a>00632     uint8_t error = 0;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="keywordflow">for</span> (i = 0; i &lt; retry; i ++) {
<a name="l00635"></a>00635         error = Cmd0(pSd, 0);
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (error != <a class="code" href="group__sdmmc__rc.html#gabb302308d4e771140374f62ca5cd49de">SDMMC_ERROR_NORESPONSE</a>)
<a name="l00637"></a>00637             <span class="keywordflow">break</span>;
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639     <span class="keywordflow">return</span> error;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 <span class="comment"></span>
<a name="l00642"></a>00642 <span class="comment">/**</span>
<a name="l00643"></a>00643 <span class="comment"> * Perform sligle block transfer</span>
<a name="l00644"></a>00644 <span class="comment"> */</span>
<a name="l00645"></a>00645 <span class="keyword">static</span> uint8_t PerformSingleTransfer(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00646"></a>00646                                      uint32_t address,
<a name="l00647"></a>00647                                      uint8_t *pData,
<a name="l00648"></a>00648                                      uint8_t isRead)
<a name="l00649"></a>00649 {
<a name="l00650"></a>00650     uint32_t status;
<a name="l00651"></a>00651     uint8_t error = 0;
<a name="l00652"></a>00652     <span class="comment">/* Reset transfer state if previous in multi- mode */</span>
<a name="l00653"></a>00653     <span class="keywordflow">if</span>(    (pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> == SD_STATE_READ)
<a name="l00654"></a>00654         || (pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> == SD_STATE_WRITE)) {
<a name="l00655"></a>00655         <span class="comment">/* Stop transfer */</span>
<a name="l00656"></a>00656         error = Cmd12(pSd, &amp;status);
<a name="l00657"></a>00657         <span class="keywordflow">if</span> (error) {
<a name="l00658"></a>00658             TRACE_ERROR(<span class="stringliteral">&quot;SingleTx.Cmd12: st%x, er%d\n\r&quot;</span>, pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a>, error);
<a name="l00659"></a>00659         }
<a name="l00660"></a>00660         pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> = SD_STATE_READY;
<a name="l00661"></a>00661         pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> = 0xFFFFFFFF;
<a name="l00662"></a>00662     }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keywordflow">if</span> ( isRead )
<a name="l00665"></a>00665     {
<a name="l00666"></a>00666         <span class="comment">/* Wait for card to be ready for data transfers */</span>
<a name="l00667"></a>00667         <span class="keywordflow">do</span>
<a name="l00668"></a>00668         {
<a name="l00669"></a>00669             error = Cmd13(pSd, &amp;status);
<a name="l00670"></a>00670             <span class="keywordflow">if</span> (error)
<a name="l00671"></a>00671             {
<a name="l00672"></a>00672                 TRACE_ERROR(<span class="stringliteral">&quot;SingleTx.RD.Cmd13: %d\n\r&quot;</span>, error);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674                 <span class="keywordflow">return</span> error;
<a name="l00675"></a>00675             }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677             <span class="keywordflow">if</span>(  ((status &amp; STATUS_STATE) == STATUS_IDLE)
<a name="l00678"></a>00678                ||((status &amp; STATUS_STATE) == <a class="code" href="_raw_nand_flash_8c.html#a64f314e17a1be8e6c8e09bb90b9ecb68">STATUS_READY</a>)
<a name="l00679"></a>00679                ||((status &amp; STATUS_STATE) == STATUS_IDENT))
<a name="l00680"></a>00680             {
<a name="l00681"></a>00681                 TRACE_ERROR(<span class="stringliteral">&quot;SingleTx.mode\n\r&quot;</span>);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683                 <span class="keywordflow">return</span> SDMMC_ERROR_NOT_INITIALIZED;
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686             <span class="comment">/* If the card is in sending data state or</span>
<a name="l00687"></a>00687 <span class="comment">               in receivce data state */</span>
<a name="l00688"></a>00688             <span class="keywordflow">if</span> ( ((status &amp; STATUS_STATE) == STATUS_RCV) ||((status &amp; STATUS_STATE) == STATUS_DATA) )
<a name="l00689"></a>00689             {
<a name="l00690"></a>00690 
<a name="l00691"></a>00691                 <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SingleTx.state = 0x%X\n\r&quot;</span>,
<a name="l00692"></a>00692                             (status &amp; STATUS_STATE) &gt;&gt; 9);
<a name="l00693"></a>00693             }
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <span class="keywordflow">while</span> ( ((status &amp; STATUS_READY_FOR_DATA) == 0) || ((status &amp; STATUS_STATE) != STATUS_TRAN) ) ;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         assert( (status &amp; STATUS_STATE) == STATUS_TRAN ) ; <span class="comment">/* &quot;SD Card can&#39;t be configured in transfer state 0x%X\n\r&quot;, (status &amp; STATUS_STATE)&gt;&gt;9 */</span>
<a name="l00699"></a>00699 
<a name="l00700"></a>00700         <span class="comment">/* Read single block */</span>
<a name="l00701"></a>00701         error = Cmd17( pSd, pData, <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address), &amp;status ) ;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="keywordflow">if</span> ( error )
<a name="l00704"></a>00704         {
<a name="l00705"></a>00705             TRACE_ERROR(<span class="stringliteral">&quot;SingleTx.Cmd17: %d\n\r&quot;</span>, error);
<a name="l00706"></a>00706             <span class="keywordflow">return</span> error;
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (status &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE))
<a name="l00710"></a>00710         {
<a name="l00711"></a>00711             TRACE_ERROR(<span class="stringliteral">&quot;CMD17.stat: %x\n\r&quot;</span>,
<a name="l00712"></a>00712                 status &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE));
<a name="l00713"></a>00713             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715         <span class="keywordflow">return</span> error;
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717     <span class="comment">/* Write */</span>
<a name="l00718"></a>00718     {
<a name="l00719"></a>00719         <span class="comment">/* Wait for card to be ready for data transfers */</span>
<a name="l00720"></a>00720         <span class="keywordflow">do</span>
<a name="l00721"></a>00721         {
<a name="l00722"></a>00722             error = Cmd13(pSd, &amp;status);
<a name="l00723"></a>00723             <span class="keywordflow">if</span> (error)
<a name="l00724"></a>00724             {
<a name="l00725"></a>00725                 TRACE_ERROR(<span class="stringliteral">&quot;SingleTx.WR.Cmd13: %d\n\r&quot;</span>, error);
<a name="l00726"></a>00726                 <span class="keywordflow">return</span> error;
<a name="l00727"></a>00727             }
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="keywordflow">while</span> ((status &amp; STATUS_READY_FOR_DATA) == 0);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <span class="comment">/* Move to Sending data state */</span>
<a name="l00733"></a>00733         error = Cmd24(pSd,
<a name="l00734"></a>00734                       pData, <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address),
<a name="l00735"></a>00735                       &amp;status);
<a name="l00736"></a>00736         <span class="keywordflow">if</span> (error)
<a name="l00737"></a>00737         {
<a name="l00738"></a>00738             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SingleTx.Cmd24: %d\n\r&quot;</span>, error);
<a name="l00739"></a>00739             <span class="keywordflow">return</span> error;
<a name="l00740"></a>00740         }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <span class="keywordflow">if</span> (status &amp; (STATUS_WRITE &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE)))
<a name="l00743"></a>00743         {
<a name="l00744"></a>00744             TRACE_ERROR(<span class="stringliteral">&quot;CMD24(0x%x).stat: %x\n\r&quot;</span>,
<a name="l00745"></a>00745                 <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address),
<a name="l00746"></a>00746                 status &amp; (STATUS_WRITE
<a name="l00747"></a>00747                             &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE)));
<a name="l00748"></a>00748             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l00749"></a>00749         }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="keywordflow">return</span> error;
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 <span class="comment"></span>
<a name="l00755"></a>00755 <span class="comment">/**</span>
<a name="l00756"></a>00756 <span class="comment"> * Move SD card to transfer state. The buffer size must be at</span>
<a name="l00757"></a>00757 <span class="comment"> * least 512 byte long. This function checks the SD card status register and</span>
<a name="l00758"></a>00758 <span class="comment"> * address the card if required before sending the transfer command.</span>
<a name="l00759"></a>00759 <span class="comment"> * Returns 0 if successful; otherwise returns an code describing the error.</span>
<a name="l00760"></a>00760 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l00761"></a>00761 <span class="comment"> * \param address  Address of the block to transfer.</span>
<a name="l00762"></a>00762 <span class="comment"> * \param nbBlocks Number of blocks to be transfer, 0 for infinite transfer.</span>
<a name="l00763"></a>00763 <span class="comment"> * \param pData    Data buffer whose size is at least the block size.</span>
<a name="l00764"></a>00764 <span class="comment"> * \param isRead   1 for read data and 0 for write data.</span>
<a name="l00765"></a>00765 <span class="comment"> */</span>
<a name="l00766"></a>00766 <span class="keyword">static</span> uint8_t MoveToTransferState(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l00767"></a>00767                                    uint32_t address,
<a name="l00768"></a>00768                                    uint16_t nbBlocks,
<a name="l00769"></a>00769                                    uint8_t *pData,
<a name="l00770"></a>00770                                    uint8_t isRead)
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772     uint32_t status;
<a name="l00773"></a>00773     uint8_t error;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <span class="keywordflow">if</span> ( (pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> == SD_STATE_READ) || (pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> == SD_STATE_WRITE) )
<a name="l00776"></a>00776     {
<a name="l00777"></a>00777         <span class="comment">/* Stop transfer */</span>
<a name="l00778"></a>00778         error = Cmd12(pSd, &amp;status);
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (error)
<a name="l00780"></a>00780         {
<a name="l00781"></a>00781             TRACE_ERROR(<span class="stringliteral">&quot;MTTranState.Cmd12: st%x, er%d\n\r&quot;</span>, pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a>, error);
<a name="l00782"></a>00782             <span class="keywordflow">return</span> error;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786     <span class="keywordflow">if</span> ( isRead )
<a name="l00787"></a>00787     {
<a name="l00788"></a>00788         <span class="comment">/* Wait for card to be ready for data transfers */</span>
<a name="l00789"></a>00789         <span class="keywordflow">do</span> {
<a name="l00790"></a>00790             error = Cmd13(pSd, &amp;status);
<a name="l00791"></a>00791             <span class="keywordflow">if</span> (error)
<a name="l00792"></a>00792             {
<a name="l00793"></a>00793                 TRACE_ERROR(<span class="stringliteral">&quot;MTTranState.RD.Cmd13: %d\n\r&quot;</span>, error);
<a name="l00794"></a>00794                 <span class="keywordflow">return</span> error;
<a name="l00795"></a>00795             }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797             <span class="keywordflow">if</span> ( ((status &amp; STATUS_STATE) == STATUS_IDLE) || ((status &amp; STATUS_STATE) == <a class="code" href="_raw_nand_flash_8c.html#a64f314e17a1be8e6c8e09bb90b9ecb68">STATUS_READY</a>) || ((status &amp; STATUS_STATE) == STATUS_IDENT) )
<a name="l00798"></a>00798             {
<a name="l00799"></a>00799                 TRACE_ERROR(<span class="stringliteral">&quot;Pb Card Identification mode\n\r&quot;</span>);
<a name="l00800"></a>00800                 <span class="keywordflow">return</span> SDMMC_ERROR_NOT_INITIALIZED;
<a name="l00801"></a>00801             }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803             <span class="comment">/* If the card is in sending data state or in receivce data state */</span>
<a name="l00804"></a>00804             <span class="keywordflow">if</span> ( ((status &amp; STATUS_STATE) == STATUS_RCV) || ((status &amp; STATUS_STATE) == STATUS_DATA) )
<a name="l00805"></a>00805             {
<a name="l00806"></a>00806                 <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;state = 0x%X\n\r&quot;</span>, (status &amp; STATUS_STATE) &gt;&gt; 9);
<a name="l00807"></a>00807             }
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         <span class="keywordflow">while</span> ( ((status &amp; STATUS_READY_FOR_DATA) == 0) || ((status &amp; STATUS_STATE) != STATUS_TRAN) ) ;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         assert( (status &amp; STATUS_STATE) == STATUS_TRAN ) ; <span class="comment">/* &quot;SD Card can&#39;t be configured in transfer state 0x%X\n\r&quot;, (status &amp; STATUS_STATE)&gt;&gt;9 */</span>
<a name="l00813"></a>00813 
<a name="l00814"></a>00814         <span class="comment">/* Move to Receiving data state */</span>
<a name="l00815"></a>00815         error = Cmd18(pSd, nbBlocks, pData, <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address), &amp;status);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817         <span class="comment">//Cmd13(pSd, &amp;status); //status -&gt; 0xB00</span>
<a name="l00818"></a>00818         <span class="keywordflow">if</span> (error)
<a name="l00819"></a>00819         {
<a name="l00820"></a>00820             TRACE_ERROR(<span class="stringliteral">&quot;MTTranState.Cmd18: %d\n\r&quot;</span>, error);
<a name="l00821"></a>00821             <span class="keywordflow">return</span> error;
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823         <span class="keywordflow">if</span> (status &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE)) {
<a name="l00824"></a>00824             TRACE_ERROR(<span class="stringliteral">&quot;CMD18.stat: %x\n\r&quot;</span>,
<a name="l00825"></a>00825                 status &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE));
<a name="l00826"></a>00826             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l00827"></a>00827         }
<a name="l00828"></a>00828     }
<a name="l00829"></a>00829     <span class="keywordflow">else</span>
<a name="l00830"></a>00830     {
<a name="l00831"></a>00831         <span class="comment">/* Wait for card to be ready for data transfers */</span>
<a name="l00832"></a>00832         <span class="keywordflow">do</span>
<a name="l00833"></a>00833         {
<a name="l00834"></a>00834             error = Cmd13(pSd, &amp;status);
<a name="l00835"></a>00835             <span class="keywordflow">if</span> (error)
<a name="l00836"></a>00836             {
<a name="l00837"></a>00837                 TRACE_ERROR(<span class="stringliteral">&quot;MoveToTransferState.WR.Cmd13: %d\n\r&quot;</span>, error);
<a name="l00838"></a>00838                 <span class="keywordflow">return</span> error;
<a name="l00839"></a>00839             }
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842         <span class="keywordflow">while</span> ((status &amp; STATUS_READY_FOR_DATA) == 0);
<a name="l00843"></a>00843         <span class="comment">/* Move to Sending data state */</span>
<a name="l00844"></a>00844         error = Cmd25(pSd,
<a name="l00845"></a>00845                       nbBlocks,
<a name="l00846"></a>00846                       pData, <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address),
<a name="l00847"></a>00847                       &amp;status);
<a name="l00848"></a>00848         <span class="keywordflow">if</span> (error) {
<a name="l00849"></a>00849             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;MoveToTransferState.Cmd25: %d\n\r&quot;</span>, error);
<a name="l00850"></a>00850             <span class="keywordflow">return</span> error;
<a name="l00851"></a>00851         }
<a name="l00852"></a>00852         <span class="keywordflow">if</span> (status &amp; (STATUS_WRITE &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE))) {
<a name="l00853"></a>00853             TRACE_ERROR(<span class="stringliteral">&quot;CMD25(0x%x, %d).stat: %x\n\r&quot;</span>,
<a name="l00854"></a>00854                 <a class="code" href="group__sdmmc__api.html#gafa090debeda4d1229a48cf7bbd928a33">SD_ADDRESS</a>(pSd,address), nbBlocks,
<a name="l00855"></a>00855                 status &amp; (STATUS_WRITE
<a name="l00856"></a>00856                             &amp; ~(STATUS_READY_FOR_DATA | STATUS_STATE)));
<a name="l00857"></a>00857             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l00858"></a>00858         }
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     <span class="keywordflow">if</span> (!error) pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> = address + (nbBlocks-1);
<a name="l00862"></a>00862     <span class="keywordflow">return</span> error;
<a name="l00863"></a>00863 }
<a name="l00864"></a>00864 <span class="comment"></span>
<a name="l00865"></a>00865 <span class="comment">/**</span>
<a name="l00866"></a>00866 <span class="comment"> * Switch card state between STBY and TRAN (or CMD and TRAN)</span>
<a name="l00867"></a>00867 <span class="comment"> * \param pSd       Pointer to a SD card driver instance.</span>
<a name="l00868"></a>00868 <span class="comment"> * \param address   Card address to TRAN, 0 to STBY</span>
<a name="l00869"></a>00869 <span class="comment"> * \param statCheck Whether to check the status before CMD7.</span>
<a name="l00870"></a>00870 <span class="comment"> */</span>
<a name="l00871"></a>00871 <span class="keyword">static</span> uint8_t MmcSelectCard(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint16_t address, uint8_t statCheck)
<a name="l00872"></a>00872 {
<a name="l00873"></a>00873     uint8_t error;
<a name="l00874"></a>00874     uint32_t  status;
<a name="l00875"></a>00875     uint32_t  targetState = address ? STATUS_TRAN : STATUS_STBY;
<a name="l00876"></a>00876     uint32_t  srcState    = address ? STATUS_STBY : STATUS_TRAN;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="comment">/* At this stage the Initialization and identification process is achieved</span>
<a name="l00879"></a>00879 <span class="comment">     * The SD card is supposed to be in Stand-by State */</span>
<a name="l00880"></a>00880     <span class="keywordflow">while</span>(statCheck) {
<a name="l00881"></a>00881         error = Cmd13(pSd, &amp;status);
<a name="l00882"></a>00882         <span class="keywordflow">if</span> (error) {
<a name="l00883"></a>00883             TRACE_ERROR(<span class="stringliteral">&quot;MmcSelectCard.Cmd13 (%d)\n\r&quot;</span>, error);
<a name="l00884"></a>00884             <span class="keywordflow">return</span> error;
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886         <span class="keywordflow">if</span> ((status &amp; STATUS_READY_FOR_DATA)) {
<a name="l00887"></a>00887             uint32_t currState = status &amp; STATUS_STATE;
<a name="l00888"></a>00888             <span class="keywordflow">if</span> (currState == targetState) <span class="keywordflow">return</span> 0;
<a name="l00889"></a>00889             <span class="keywordflow">if</span> (currState != srcState) {
<a name="l00890"></a>00890                 TRACE_ERROR(<span class="stringliteral">&quot;MmcSelectCard, wrong state %x\n\r&quot;</span>, currState);
<a name="l00891"></a>00891                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l00892"></a>00892             }
<a name="l00893"></a>00893             <span class="keywordflow">break</span>;
<a name="l00894"></a>00894         }
<a name="l00895"></a>00895     }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     <span class="comment">/* witch to TRAN mode to Select the current SD/MMC</span>
<a name="l00898"></a>00898 <span class="comment">     * so that SD ACMD6 can process or EXT_CSD can read. */</span>
<a name="l00899"></a>00899     error = Cmd7(pSd, address);
<a name="l00900"></a>00900     <span class="keywordflow">if</span> (error == <a class="code" href="group__sdmmc__rc.html#ga5bd95585e6fa284ccad5554d0919acdf">SDMMC_ERROR_NOT_INITIALIZED</a> &amp;&amp; address == 0) {}
<a name="l00901"></a>00901     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error) {
<a name="l00902"></a>00902         TRACE_ERROR(<span class="stringliteral">&quot;MmcSelectCard.Cmd7 (%d)\n\r&quot;</span>, error);
<a name="l00903"></a>00903     }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905     <span class="keywordflow">return</span> error;
<a name="l00906"></a>00906 }
<a name="l00907"></a>00907 <span class="comment"></span>
<a name="l00908"></a>00908 <span class="comment">/**</span>
<a name="l00909"></a>00909 <span class="comment"> * Get MMC EXT_CSD information</span>
<a name="l00910"></a>00910 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l00911"></a>00911 <span class="comment"> */</span>
<a name="l00912"></a>00912 <span class="keyword">static</span> <span class="keywordtype">void</span> MmcGetExtInformation(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00913"></a>00913 {
<a name="l00914"></a>00914     uint8_t error;
<a name="l00915"></a>00915     <span class="comment">/* MMC 4.0 Higher version */</span>
<a name="l00916"></a>00916     <span class="keywordflow">if</span>(<a class="code" href="group__sdmmc__mem__api.html#gad82fdd0c4e9da984885df36992db6612" title="CSD structure 00b Version 1.0 01b version 2.0 High Cap.">SD_CSD_STRUCTURE</a>(pSd) &gt;= 2 &amp;&amp; <a class="code" href="group__sdmmc__api.html#ga07bc6ff131eea07308e69fcaa30213cf">MMC_IsVer4</a>(pSd)) {
<a name="l00917"></a>00917 
<a name="l00918"></a>00918         error = <a class="code" href="group__sdmmc__hal.html#ga7b77a1a320f31b979c72b95fe150c34c">MmcCmd8</a>(pSd, (uint8_t*)pSd-&gt;<a class="code" href="struct_sd_card.html#a6605007bdc7d2cb6d440e3b57f3485d2">extData</a>, NULL);
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (error) {
<a name="l00920"></a>00920             TRACE_ERROR(<span class="stringliteral">&quot;MmcGetExt.Cmd8: %d\n\r&quot;</span>, error);
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923 }
<a name="l00924"></a>00924 <span class="comment"></span>
<a name="l00925"></a>00925 <span class="comment">/**</span>
<a name="l00926"></a>00926 <span class="comment"> * Get SD/MMC memory max transfer speed in K.</span>
<a name="l00927"></a>00927 <span class="comment"> * \param pSd Pointer to a SD card driver instance.</span>
<a name="l00928"></a>00928 <span class="comment"> */</span>
<a name="l00929"></a>00929 <span class="keyword">static</span> uint32_t SdmmcGetMaxSpeed(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00930"></a>00930 {
<a name="l00931"></a>00931     uint32_t speed = 0;
<a name="l00932"></a>00932     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) {
<a name="l00933"></a>00933         speed = SdmmcDecodeTransSpeed(<a class="code" href="group__sdmmc__mem__api.html#ga9ba1a5be408418ae43af9d5ba580bac8" title="Max. data transfer rate.">SD_CSD_TRAN_SPEED</a>(pSd),
<a name="l00934"></a>00934             sdmmcTransUnits,
<a name="l00935"></a>00935             ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) == <a class="code" href="group__sdmmc__cardtype.html#gaa6a8c3512b0026e1e1e868519c32ea5f">CARD_TYPE_bmSD</a>) ?
<a name="l00936"></a>00936                     sdTransMultipliers : mmcTransMultipliers);
<a name="l00937"></a>00937     }
<a name="l00938"></a>00938     <span class="keywordflow">return</span> speed;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 <span class="comment"></span>
<a name="l00941"></a>00941 <span class="comment">/**</span>
<a name="l00942"></a>00942 <span class="comment"> * Get SDIO max transfer speed, in K.</span>
<a name="l00943"></a>00943 <span class="comment"> * \param pSd Pointer to a SD card driver instance.</span>
<a name="l00944"></a>00944 <span class="comment"> */</span>
<a name="l00945"></a>00945 <span class="keyword">static</span> uint32_t SdioGetMaxSpeed(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947     uint8_t error;
<a name="l00948"></a>00948     uint32_t speed = 0;
<a name="l00949"></a>00949     uint32_t addr = 0;
<a name="l00950"></a>00950     uint8_t  buf[6];
<a name="l00951"></a>00951     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga0881e572c2c166e60e7f050546277405">CARD_TYPE_bmSDIO</a>) {
<a name="l00952"></a>00952         <span class="comment">/* Check Func0 tuple in CIS area */</span>
<a name="l00953"></a>00953         error = <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd,
<a name="l00954"></a>00954                                 <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gaa05cd13e0dd708ab28d17e657e462c8e">SDIO_CIS_PTR_REG</a>,
<a name="l00955"></a>00955                                 (uint8_t*)&amp;addr, 3);
<a name="l00956"></a>00956         <span class="keywordflow">if</span> (error) {
<a name="l00957"></a>00957             TRACE_ERROR(<span class="stringliteral">&quot;SdioUpdateCardInformation.RdDirect: %u\n\r&quot;</span>, error);
<a name="l00958"></a>00958             <span class="keywordflow">return</span> error;
<a name="l00959"></a>00959         }
<a name="l00960"></a>00960         error = SdioFindTuples(pSd, addr, 256, NULL, &amp;addr);
<a name="l00961"></a>00961         <span class="keywordflow">if</span> (error) {
<a name="l00962"></a>00962             TRACE_ERROR(<span class="stringliteral">&quot;SdioUpdateCardInformation.FindTuple: %u\n\r&quot;</span>, error);
<a name="l00963"></a>00963             <span class="keywordflow">return</span> error;
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965         <span class="keywordflow">if</span> (addr) {
<a name="l00966"></a>00966             <span class="comment">/* Fun0 tuple: fn0_blk_siz &amp; max_tran_speed */</span>
<a name="l00967"></a>00967             <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, addr, buf, 6);
<a name="l00968"></a>00968             speed = SdmmcDecodeTransSpeed(buf[5],
<a name="l00969"></a>00969                                           sdmmcTransUnits,
<a name="l00970"></a>00970                                           sdTransMultipliers);
<a name="l00971"></a>00971         }
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973     <span class="keywordflow">return</span> speed;
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 <span class="comment"></span>
<a name="l00976"></a>00976 <span class="comment">/**</span>
<a name="l00977"></a>00977 <span class="comment"> * Get SCR and SD Status information</span>
<a name="l00978"></a>00978 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l00979"></a>00979 <span class="comment"> */</span>
<a name="l00980"></a>00980 <span class="keyword">static</span> <span class="keywordtype">void</span> SdGetExtInformation(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982     uint8_t error;
<a name="l00983"></a>00983 
<a name="l00984"></a>00984     <span class="comment">/* SD Status */</span>
<a name="l00985"></a>00985     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#aab58ab224ab7bcdd88f4623105816546">optCmdBitMap</a> &amp; SD_ACMD13_SUPPORT) {
<a name="l00986"></a>00986         error = Acmd13(pSd, &amp;pSd-&gt;<a class="code" href="struct_sd_card.html#a6605007bdc7d2cb6d440e3b57f3485d2">extData</a>[<a class="code" href="group__sdmmc__mem__api.html#gae352eb67874d4412f137e14ade146c0a">SD_EXT_OFFSET_SD_STAT</a>]);
<a name="l00987"></a>00987         <span class="keywordflow">if</span> (error) {
<a name="l00988"></a>00988             TRACE_ERROR(<span class="stringliteral">&quot;SdGetExt.Acmd13: %d\n\r&quot;</span>, error);
<a name="l00989"></a>00989             pSd-&gt;<a class="code" href="struct_sd_card.html#aab58ab224ab7bcdd88f4623105816546">optCmdBitMap</a> &amp;= ~SD_ACMD13_SUPPORT;
<a name="l00990"></a>00990         }
<a name="l00991"></a>00991     }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="comment">/* SD SCR */</span>
<a name="l00994"></a>00994     error = Acmd51(pSd, &amp;pSd-&gt;<a class="code" href="struct_sd_card.html#a6605007bdc7d2cb6d440e3b57f3485d2">extData</a>[<a class="code" href="group__sdmmc__mem__api.html#gaf7abf1029ecbf03595f8ee033e32cb5f">SD_EXT_OFFSET_SD_SCR</a>]);
<a name="l00995"></a>00995     <span class="keywordflow">if</span> (error) {
<a name="l00996"></a>00996         TRACE_ERROR(<span class="stringliteral">&quot;SdGetExt.Acmd51: %d\n\r&quot;</span>, error);
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998 }
<a name="l00999"></a>00999 <span class="comment"></span>
<a name="l01000"></a>01000 <span class="comment">/**</span>
<a name="l01001"></a>01001 <span class="comment"> * Update SD/MMC information.</span>
<a name="l01002"></a>01002 <span class="comment"> * Update CSD for card speed switch.</span>
<a name="l01003"></a>01003 <span class="comment"> * Update ExtDATA for any card function switch.</span>
<a name="l01004"></a>01004 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l01005"></a>01005 <span class="comment"> * \return error code when update CSD error.</span>
<a name="l01006"></a>01006 <span class="comment"> */</span>
<a name="l01007"></a>01007 <span class="keyword">static</span> <span class="keywordtype">void</span> SdMmcUpdateInformation(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01008"></a>01008                                    uint8_t csd,
<a name="l01009"></a>01009                                    uint8_t extData)
<a name="l01010"></a>01010 {
<a name="l01011"></a>01011     uint8_t error;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013     <span class="comment">/* Update CSD for new TRAN_SPEED value */</span>
<a name="l01014"></a>01014     <span class="keywordflow">if</span> (csd) {
<a name="l01015"></a>01015         MmcSelectCard(pSd, 0, 1);
<a name="l01016"></a>01016         Delay(800);
<a name="l01017"></a>01017         error = Cmd9(pSd);
<a name="l01018"></a>01018         <span class="keywordflow">if</span> (error ) {
<a name="l01019"></a>01019             TRACE_ERROR(<span class="stringliteral">&quot;SdMmcUpdateInfo.Cmd9 (%d)\n\r&quot;</span>, error);
<a name="l01020"></a>01020             <span class="keywordflow">return</span>;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022         error = MmcSelectCard(pSd, pSd-&gt;<a class="code" href="struct_sd_card.html#a922af00ff450d07074262014f01429a0">cardAddress</a>, 1);
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024     <span class="keywordflow">if</span> (extData) {
<a name="l01025"></a>01025         <span class="keywordflow">switch</span>(pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) {
<a name="l01026"></a>01026             <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__cardtype.html#gaa6a8c3512b0026e1e1e868519c32ea5f">CARD_TYPE_bmSD</a>:    SdGetExtInformation(pSd);   <span class="keywordflow">break</span>;
<a name="l01027"></a>01027             <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__cardtype.html#ga31828db74f62996887d42d783d05d609">CARD_TYPE_bmMMC</a>:   MmcGetExtInformation(pSd);  <span class="keywordflow">break</span>;
<a name="l01028"></a>01028             <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l01029"></a>01029         }
<a name="l01030"></a>01030     }
<a name="l01031"></a>01031 }
<a name="l01032"></a>01032 <span class="comment"></span>
<a name="l01033"></a>01033 <span class="comment">/**</span>
<a name="l01034"></a>01034 <span class="comment"> * \brief Check HS capability and enable it</span>
<a name="l01035"></a>01035 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l01036"></a>01036 <span class="comment"> */</span>
<a name="l01037"></a>01037 <span class="keyword">static</span> uint8_t SdMmcEnableHighSpeed(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039     uint8_t  error;
<a name="l01040"></a>01040     uint32_t status;
<a name="l01041"></a>01041     uint8_t io, sd, mmc;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     io  = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDIO) &gt; 0);
<a name="l01044"></a>01044     sd  = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDMMC) == <a class="code" href="group__sdmmc__cardtype.html#gaa6a8c3512b0026e1e1e868519c32ea5f">CARD_TYPE_bmSD</a>);
<a name="l01045"></a>01045     mmc = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDMMC) == <a class="code" href="group__sdmmc__cardtype.html#ga31828db74f62996887d42d783d05d609">CARD_TYPE_bmMMC</a>);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     <span class="comment">/* Check host driver capability */</span>
<a name="l01048"></a>01048     <span class="keywordflow">if</span> (<a class="code" href="group__sdmmc__hal.html#gae5f08b18f15d39b8d293cb3e455f5363">SdmmcGetProperty</a>(pSd, <a class="code" href="group__sdmmc__properties.html#gab52e9d63a0b13b12d2443a65802727fe">SDMMC_PROP_HS_MODE</a>, NULL) == 0) {
<a name="l01049"></a>01049         TRACE_INFO(<span class="stringliteral">&quot;HS Mode not supported by Host\n\r&quot;</span>);
<a name="l01050"></a>01050         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01051"></a>01051     }
<a name="l01052"></a>01052     <span class="comment">/* Check MMC */</span>
<a name="l01053"></a>01053     <span class="keywordflow">if</span> (mmc) {
<a name="l01054"></a>01054         <span class="comment">/* MMC card type 3 (HS) */</span>
<a name="l01055"></a>01055         <span class="comment">//if (SD_CSD_STRUCTURE(pSd) &gt;= 2 &amp;&amp; (SD_EXTCSD_CARD_TYPE(pSd) &amp; 0x2)) {</span>
<a name="l01056"></a>01056         <span class="keywordflow">if</span> (<a class="code" href="group__sdmmc__api.html#ga09797c276041c74e4d68fcbb2f8de206">MMC_IsHsModeSupported</a>(pSd)) {
<a name="l01057"></a>01057             <span class="comment">/* Try switch to HS mode */</span>
<a name="l01058"></a>01058             MmcCmd6Arg cmd6Arg = {
<a name="l01059"></a>01059                 0x3,
<a name="l01060"></a>01060                 SD_EXTCSD_HS_TIMING_INDEX,
<a name="l01061"></a>01061                 SD_EXTCSD_HS_TIMING_ENABLE,
<a name="l01062"></a>01062                 0};
<a name="l01063"></a>01063             error = <a class="code" href="group__sdmmc__hal.html#ga2003d0fa01e6ecdbb5baa1bfddacc610">MmcCmd6</a>(pSd, &amp;cmd6Arg, &amp;status, NULL);
<a name="l01064"></a>01064             <span class="keywordflow">if</span> (error) {
<a name="l01065"></a>01065                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcEnableHS.Cmd6: %u\n\r&quot;</span>, error);
<a name="l01066"></a>01066                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01067"></a>01067             }
<a name="l01068"></a>01068             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; STATUS_MMC_SWITCH) {
<a name="l01069"></a>01069                 TRACE_ERROR(<span class="stringliteral">&quot;Mmc Switch HS: %x\n\r&quot;</span>, status);
<a name="l01070"></a>01070                 <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01071"></a>01071             }
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073         <span class="keywordflow">else</span> {
<a name="l01074"></a>01074             TRACE_INFO(<span class="stringliteral">&quot;MMC without HS support\n\r&quot;</span>);
<a name="l01075"></a>01075             <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01076"></a>01076         }
<a name="l01077"></a>01077         TRACE_WARNING(<span class="stringliteral">&quot;MMC HS Enabled\n\r&quot;</span>);
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079     <span class="comment">/* SD (+IO) */</span>
<a name="l01080"></a>01080     <span class="keywordflow">else</span> {
<a name="l01081"></a>01081         <span class="keywordflow">if</span> (io) {
<a name="l01082"></a>01082             <span class="comment">/* Check CIA.HS */</span>
<a name="l01083"></a>01083             status = 0;
<a name="l01084"></a>01084             error = Cmd52(pSd, 0, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, 0, <a class="code" href="group__sdio__cccr__def.html#gabacbfdd6b4d6f286af09cd8a15d0d6ff">SDIO_HS_REG</a>, &amp;status);
<a name="l01085"></a>01085             <span class="keywordflow">if</span> (error) {
<a name="l01086"></a>01086                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcEnableHS.Cmd52: %u\n\r&quot;</span>, error);
<a name="l01087"></a>01087                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01088"></a>01088             }
<a name="l01089"></a>01089             <span class="keywordflow">if</span> ((status &amp; <a class="code" href="group__sdio__cccr__def.html#gaf45af188ca3ecc4264acf0522e0141ed">SDIO_SHS</a>) == 0) {
<a name="l01090"></a>01090                 TRACE_INFO(<span class="stringliteral">&quot;HS Mode not supported by SDIO\n\r&quot;</span>);
<a name="l01091"></a>01091                 <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01092"></a>01092             }
<a name="l01093"></a>01093             <span class="comment">/* Enable HS mode */</span>
<a name="l01094"></a>01094             <span class="keywordflow">else</span> {
<a name="l01095"></a>01095                 status = SDIO_EHS;
<a name="l01096"></a>01096                 error = Cmd52(pSd, 1, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, 1, <a class="code" href="group__sdio__cccr__def.html#gabacbfdd6b4d6f286af09cd8a15d0d6ff">SDIO_HS_REG</a>, &amp;status);
<a name="l01097"></a>01097                 <span class="keywordflow">if</span> (error) {
<a name="l01098"></a>01098                     TRACE_ERROR(<span class="stringliteral">&quot;SdMmcEnableHS.Cmd52 H: %u\n\r&quot;</span>, error);
<a name="l01099"></a>01099                     <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01100"></a>01100                 }
<a name="l01101"></a>01101                 <span class="keywordflow">if</span> (status &amp; <a class="code" href="group__sdio__cccr__def.html#ga6c78ba330227b8fd273068b90d4d1138">SDIO_EHS</a>) {
<a name="l01102"></a>01102                     TRACE_WARNING(<span class="stringliteral">&quot;SDIO HS Enabled\n\r&quot;</span>);
<a name="l01103"></a>01103                 }
<a name="l01104"></a>01104             }
<a name="l01105"></a>01105         }
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (sd) {
<a name="l01107"></a>01107             <span class="comment">/* Check version */</span>
<a name="l01108"></a>01108             <span class="comment">//if (SD_SCR_SD_SPEC(pSd) &gt;= SD_SCR_SD_SPEC_1_10) {</span>
<a name="l01109"></a>01109             <span class="keywordflow">if</span> (<a class="code" href="group__sdmmc__api.html#ga6d66d1883c2ee86470031e82b95a45b2">SD_IsHsModeSupported</a>(pSd)) {
<a name="l01110"></a>01110                 <span class="comment">/* Try enable HS mode */</span>
<a name="l01111"></a>01111                 SdCmd6Arg cmd6Arg = {
<a name="l01112"></a>01112                     1, 0, 0xF, 0xF, 0xF, 0xF, 0, 1
<a name="l01113"></a>01113                 };
<a name="l01114"></a>01114                 uint32_t switchStatus[512/32];
<a name="l01115"></a>01115                 error = <a class="code" href="group__sdmmc__hal.html#ga03f1fb5d45e3e56184e57b4a0a5b0615">SdCmd6</a>(pSd, &amp;cmd6Arg, switchStatus, &amp;status, NULL);
<a name="l01116"></a>01116                 <span class="keywordflow">if</span> (error || (status &amp; STATUS_SWITCH_ERROR)) {
<a name="l01117"></a>01117                     TRACE_INFO(<span class="stringliteral">&quot;SD HS Fail\n\r&quot;</span>);
<a name="l01118"></a>01118                     <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01119"></a>01119                 }
<a name="l01120"></a>01120                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SD_SW_STAT_FUN_GRP1_RC(switchStatus)
<a name="l01121"></a>01121                                 == SD_SW_STAT_FUN_GRP_RC_ERROR) {
<a name="l01122"></a>01122                     TRACE_INFO(<span class="stringliteral">&quot;SD HS Not Supported\n\r&quot;</span>);
<a name="l01123"></a>01123                     <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01124"></a>01124                 }
<a name="l01125"></a>01125                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SD_SW_STAT_FUN_GRP1_BUSY(switchStatus)) {
<a name="l01126"></a>01126                     TRACE_INFO(<span class="stringliteral">&quot;SD HS Locked\n\r&quot;</span>);
<a name="l01127"></a>01127                     <span class="keywordflow">return</span> SDMMC_ERROR_BUSY;
<a name="l01128"></a>01128                 }
<a name="l01129"></a>01129                 <span class="keywordflow">else</span> {
<a name="l01130"></a>01130                     TRACE_WARNING(<span class="stringliteral">&quot;SD HS Enabled\n\r&quot;</span>);
<a name="l01131"></a>01131                 }
<a name="l01132"></a>01132             }
<a name="l01133"></a>01133             <span class="keywordflow">else</span> {
<a name="l01134"></a>01134                 TRACE_INFO(<span class="stringliteral">&quot;HS Not Supported in SD Rev 0x%x\n\r&quot;</span>,
<a name="l01135"></a>01135                     SD_SCR_SD_SPEC(pSd));
<a name="l01136"></a>01136                 <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01137"></a>01137             }
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139     }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="comment">/* Enable Host HS mode */</span>
<a name="l01142"></a>01142     <a class="code" href="group__sdmmc__hal.html#ga01a5dac1a7924ca963471bd00d6eb460">SdmmcEnableHsMode</a>(pSd, 1);
<a name="l01143"></a>01143     <span class="keywordflow">return</span> 0;
<a name="l01144"></a>01144 }
<a name="l01145"></a>01145 <span class="comment"></span>
<a name="l01146"></a>01146 <span class="comment">/**</span>
<a name="l01147"></a>01147 <span class="comment"> * \brief Check bus width capability and enable it</span>
<a name="l01148"></a>01148 <span class="comment"> */</span>
<a name="l01149"></a>01149 <span class="keyword">static</span> uint8_t SdMmcDesideBuswidth(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151     uint8_t  error, busWidth;
<a name="l01152"></a>01152     uint32_t status;
<a name="l01153"></a>01153     uint8_t mmc;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     <span class="comment">/* Best width that the card support */</span>
<a name="l01156"></a>01156     busWidth = <a class="code" href="group__sdmmc__hal.html#gae5f08b18f15d39b8d293cb3e455f5363">SdmmcGetProperty</a>(pSd, <a class="code" href="group__sdmmc__properties.html#ga3295bdadb4cad94f4f071aac87be1707">SDMMC_PROP_BUS_MODE</a>, NULL);
<a name="l01157"></a>01157 
<a name="l01158"></a>01158     mmc = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDMMC) == <a class="code" href="group__sdmmc__cardtype.html#ga31828db74f62996887d42d783d05d609">CARD_TYPE_bmMMC</a>);
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     <span class="keywordflow">if</span> (mmc) {
<a name="l01161"></a>01161         <span class="comment">/* Check MMC revision 4 or later (1/4/8 bit mode) */</span>
<a name="l01162"></a>01162         <span class="keywordflow">if</span> (<a class="code" href="group__sdmmc__mem__api.html#gab86f2c60972ec452125b484d22bc6a35" title="System Specification Version Number.">SD_CSD_SPEC_VERS</a>(pSd) &gt;= 4) {
<a name="l01163"></a>01163             <span class="comment">/* Select what&#39;s HC supported */</span>
<a name="l01164"></a>01164             MmcCmd6Arg cmd6Arg = {
<a name="l01165"></a>01165                 0x1, SD_EXTCSD_BUS_WIDTH_INDEX, SD_EXTCSD_BUS_WIDTH_1BIT, 0
<a name="l01166"></a>01166             };
<a name="l01167"></a>01167             <span class="keywordflow">switch</span>(busWidth) {
<a name="l01168"></a>01168                 <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__busmode.html#gabb3ba235f6032d10d27baf67a1f3a672">SDMMC_BUS_4_BIT</a>:
<a name="l01169"></a>01169                     cmd6Arg.value = SD_EXTCSD_BUS_WIDTH_4BIT;
<a name="l01170"></a>01170                     <span class="keywordflow">break</span>;
<a name="l01171"></a>01171                 <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__busmode.html#ga9f503d46f9af9abc17f0b72d0455356c">SDMMC_BUS_8_BIT</a>:
<a name="l01172"></a>01172                     cmd6Arg.value = SD_EXTCSD_BUS_WIDTH_8BIT;
<a name="l01173"></a>01173                     <span class="keywordflow">break</span>;
<a name="l01174"></a>01174                 <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__busmode.html#ga0d66dc2b7e593de90ef9e416bbcc3d09">SDMMC_BUS_1_BIT</a>:
<a name="l01175"></a>01175                     <span class="keywordflow">break</span>;
<a name="l01176"></a>01176             }
<a name="l01177"></a>01177             error = <a class="code" href="group__sdmmc__hal.html#ga2003d0fa01e6ecdbb5baa1bfddacc610">MmcCmd6</a>(pSd, &amp;cmd6Arg, &amp;status, NULL);
<a name="l01178"></a>01178             <span class="keywordflow">if</span> (error) {
<a name="l01179"></a>01179                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcSetBuswidth.Cmd6: %u\n\r&quot;</span>, error);
<a name="l01180"></a>01180                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01181"></a>01181             }
<a name="l01182"></a>01182             <span class="keywordflow">else</span> {
<a name="l01183"></a>01183                 <span class="keywordflow">if</span> (status &amp; STATUS_MMC_SWITCH) {
<a name="l01184"></a>01184                     TRACE_ERROR(<span class="stringliteral">&quot;MMC Bus Switch error %x\n\r&quot;</span>, status);
<a name="l01185"></a>01185                     <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01186"></a>01186                 }
<a name="l01187"></a>01187                 TRACE_WARNING(<span class="stringliteral">&quot;MMC Bus mode %x\n\r&quot;</span>, busWidth);
<a name="l01188"></a>01188             }
<a name="l01189"></a>01189         }
<a name="l01190"></a>01190         <span class="keywordflow">else</span> {
<a name="l01191"></a>01191             TRACE_WARNING(<span class="stringliteral">&quot;MMC 1-bit only\n\r&quot;</span>);
<a name="l01192"></a>01192             <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01193"></a>01193         }
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195     <span class="keywordflow">else</span> {
<a name="l01196"></a>01196         <span class="comment">/* SD(IO): switch to 4-bit mode ? */</span>
<a name="l01197"></a>01197         uint8_t io  = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDIO) &gt; 0);
<a name="l01198"></a>01198         uint8_t sd  = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDMMC) == <a class="code" href="group__sdmmc__cardtype.html#gaa6a8c3512b0026e1e1e868519c32ea5f">CARD_TYPE_bmSD</a>);
<a name="l01199"></a>01199         <span class="keywordflow">if</span> (busWidth == <a class="code" href="group__sdmmc__busmode.html#ga0d66dc2b7e593de90ef9e416bbcc3d09">SDMMC_BUS_1_BIT</a>)
<a name="l01200"></a>01200             <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01201"></a>01201         <span class="comment">/* No 8-bit mode, default to 4-bit mode */</span>
<a name="l01202"></a>01202         busWidth = SDMMC_BUS_4_BIT;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204         <span class="comment">/* SDIO */</span>
<a name="l01205"></a>01205         <span class="keywordflow">if</span> (io) {
<a name="l01206"></a>01206             <span class="comment">/* SDIO 1 bit only */</span>
<a name="l01207"></a>01207             busWidth = SDMMC_BUS_1_BIT;
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         <span class="comment">/* SD */</span>
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (sd) {
<a name="l01212"></a>01212             error = Acmd6(pSd, busWidth);
<a name="l01213"></a>01213             <span class="keywordflow">if</span> (error) {
<a name="l01214"></a>01214                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcSetBusWidth.Acmd6: %u\n\r&quot;</span>, error);
<a name="l01215"></a>01215                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01216"></a>01216             }
<a name="l01217"></a>01217             TRACE_WARNING(<span class="stringliteral">&quot;SD 4-bit mode\n\r&quot;</span>);
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     <span class="comment">/* Switch to selected bus mode */</span>
<a name="l01222"></a>01222     pSd-&gt;<a class="code" href="struct_sd_card.html#a87793f6807f0e11c618e55c38a0b5839">busMode</a> = busWidth;
<a name="l01223"></a>01223     <a class="code" href="group__sdmmc__hal.html#gabd2bfe750d60ce6c59defece41e5789c">SdmmcSetBusWidth</a>(pSd, busWidth);
<a name="l01224"></a>01224     <span class="keywordflow">return</span> 0;
<a name="l01225"></a>01225 }
<a name="l01226"></a>01226 <span class="comment"></span>
<a name="l01227"></a>01227 <span class="comment">/**</span>
<a name="l01228"></a>01228 <span class="comment"> * \brief Run the SD/MMC/SDIO Mode initialization sequence.</span>
<a name="l01229"></a>01229 <span class="comment"> * This function runs the initialization procedure and the identification</span>
<a name="l01230"></a>01230 <span class="comment"> * process. Then it leaves the card in ready state. The following procedure must</span>
<a name="l01231"></a>01231 <span class="comment"> * check the card type and continue to put the card into tran(for memory card)</span>
<a name="l01232"></a>01232 <span class="comment"> * or cmd(for io card) state for data exchange.</span>
<a name="l01233"></a>01233 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01234"></a>01234 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;SD_ERROR code&quot;.</span>
<a name="l01235"></a>01235 <span class="comment"> */</span>
<a name="l01236"></a>01236 <span class="keyword">static</span> uint8_t SdMmcIdentify(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238     uint8_t mem = 0, io = 0, f8 = 0, mp = 1, ccs = 0;
<a name="l01239"></a>01239     uint32_t status;
<a name="l01240"></a>01240     uint8_t error;
<a name="l01241"></a>01241     <span class="comment">/* Reset HC to default HS and BusMode */</span>
<a name="l01242"></a>01242     <a class="code" href="group__sdmmc__hal.html#ga01a5dac1a7924ca963471bd00d6eb460">SdmmcEnableHsMode</a>(pSd, 0);
<a name="l01243"></a>01243     <a class="code" href="group__sdmmc__hal.html#gabd2bfe750d60ce6c59defece41e5789c">SdmmcSetBusWidth</a>(pSd, <a class="code" href="group__sdmmc__busmode.html#ga0d66dc2b7e593de90ef9e416bbcc3d09">SDMMC_BUS_1_BIT</a>);
<a name="l01244"></a>01244     <span class="comment">/* Reset SDIO: CMD52, write 1 to RES bit in CCCR (bit 3 of register 6) */</span>
<a name="l01245"></a>01245     status = SDIO_RES;
<a name="l01246"></a>01246     error = Cmd52(pSd, 1, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, 0, <a class="code" href="group__sdio__cccr__def.html#ga562a19e5ab1158c6d831e8806cabb0c2">SDIO_IOA_REG</a>, &amp;status);
<a name="l01247"></a>01247     <span class="keywordflow">if</span> (!error &amp;&amp; ((status &amp; <a class="code" href="group__sdio__status__bm.html#ga73b5c422c2ff90724ac592289cfc524b">STATUS_SDIO_R5</a>)==0))
<a name="l01248"></a>01248     {
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250     <span class="keywordflow">else</span>
<a name="l01251"></a>01251     {
<a name="l01252"></a>01252         <span class="keywordflow">if</span> (error == <a class="code" href="group__sdmmc__rc.html#gabb302308d4e771140374f62ca5cd49de">SDMMC_ERROR_NORESPONSE</a>)
<a name="l01253"></a>01253         {
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255         <span class="keywordflow">else</span>
<a name="l01256"></a>01256         {
<a name="l01257"></a>01257             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SdMmcIdentify.Cmd52 fail: %u, %x\n\r&quot;</span>, error, status);
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     <span class="comment">/* Reset MEM: CMD0 */</span>
<a name="l01262"></a>01262     error = SwReset(pSd, 1);
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (error) {
<a name="l01264"></a>01264         <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SdMmcIdentify.SwReset fail: %u\n\r&quot;</span>, error);
<a name="l01265"></a>01265     }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     <span class="comment">/* CMD8 is newly added in the Physical Layer Specification Version 2.00 to</span>
<a name="l01268"></a>01268 <span class="comment">     * support multiple voltage ranges and used to check whether the card</span>
<a name="l01269"></a>01269 <span class="comment">     * supports supplied voltage. The version 2.00 host shall issue CMD8 and</span>
<a name="l01270"></a>01270 <span class="comment">     * verify voltage before card initialization.</span>
<a name="l01271"></a>01271 <span class="comment">     * The host that does not support CMD8 shall supply high voltage range... */</span>
<a name="l01272"></a>01272     error = <a class="code" href="group__sdmmc__hal.html#ga6da63da1bdaa521e07e3913af09e77ea">SdCmd8</a>(pSd, 1, NULL);
<a name="l01273"></a>01273     <span class="keywordflow">if</span> (error == 0) f8 = 1;
<a name="l01274"></a>01274     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error != <a class="code" href="group__sdmmc__rc.html#gabb302308d4e771140374f62ca5cd49de">SDMMC_ERROR_NORESPONSE</a>) {
<a name="l01275"></a>01275         TRACE_ERROR(<span class="stringliteral">&quot;SdMmcIdentify.Cmd8: %u\n\r&quot;</span>, error);
<a name="l01276"></a>01276         <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01277"></a>01277     }
<a name="l01278"></a>01278     <span class="comment">/* Delay after &quot;no response&quot; */</span>
<a name="l01279"></a>01279     <span class="keywordflow">else</span> Delay(800);
<a name="l01280"></a>01280 
<a name="l01281"></a>01281     <span class="comment">/* CMD5 is newly added for SDIO initialize &amp; power on */</span>
<a name="l01282"></a>01282     status = 0;
<a name="l01283"></a>01283     error = Cmd5(pSd, &amp;status);
<a name="l01284"></a>01284     <span class="keywordflow">if</span> (error) {
<a name="l01285"></a>01285         TRACE_WARNING(<span class="stringliteral">&quot;SdMmcIdentify.Cmd5: %u\n\r&quot;</span>, error)
<a name="l01286"></a>01286     }
<a name="l01287"></a>01287     <span class="comment">/* Card has SDIO function */</span>
<a name="l01288"></a>01288     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((status &amp; OCR_SDIO_NF) &gt; 0) {
<a name="l01289"></a>01289         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd5Retries = 10000;
<a name="l01290"></a>01290         <span class="keywordflow">do</span> {
<a name="l01291"></a>01291             status &amp;= SDMMC_HOST_VOLTAGE_RANGE;
<a name="l01292"></a>01292             error = Cmd5(pSd, &amp;status);
<a name="l01293"></a>01293             <span class="keywordflow">if</span> (status &amp; OCR_POWER_UP_BUSY) <span class="keywordflow">break</span>;
<a name="l01294"></a>01294         } <span class="keywordflow">while</span>(!error &amp;&amp; cmd5Retries --);
<a name="l01295"></a>01295         <span class="keywordflow">if</span> (error) {
<a name="l01296"></a>01296             TRACE_ERROR(<span class="stringliteral">&quot;SdMmcIdentify.Cmd5 V: %u\n\r&quot;</span>, error);
<a name="l01297"></a>01297             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01298"></a>01298         }
<a name="l01299"></a>01299         io = 1;
<a name="l01300"></a>01300         TRACE_INFO(<span class="stringliteral">&quot;SDIO\n\r&quot;</span>);
<a name="l01301"></a>01301         <span class="comment">/* IO only ?*/</span>
<a name="l01302"></a>01302         mp = ((status &amp; OCR_SDIO_MP) &gt; 0);
<a name="l01303"></a>01303     }
<a name="l01304"></a>01304     <span class="comment">/* Has memory: SD/MMC/COMBO */</span>
<a name="l01305"></a>01305     <span class="keywordflow">if</span> (mp) {
<a name="l01306"></a>01306         <span class="comment">/* Try SD memory initialize */</span>
<a name="l01307"></a>01307         error = Acmd41(pSd, f8, &amp;ccs);
<a name="l01308"></a>01308         <span class="keywordflow">if</span> (error) {
<a name="l01309"></a>01309             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd1Retries = 10000;
<a name="l01310"></a>01310             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SdMmcIdentify.Acmd41: %u, try MMC\n\r&quot;</span>, error);
<a name="l01311"></a>01311             <span class="comment">/* Try MMC initialize */</span>
<a name="l01312"></a>01312             error = SwReset(pSd, 10);
<a name="l01313"></a>01313             <span class="keywordflow">if</span> (error) {
<a name="l01314"></a>01314                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcIdentify.Mmc.SwReset: %u\n\r&quot;</span>, error);
<a name="l01315"></a>01315                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01316"></a>01316             }
<a name="l01317"></a>01317             ccs = 1;
<a name="l01318"></a>01318             <span class="keywordflow">do</span> { error = Cmd1(pSd, &amp;ccs); }<span class="keywordflow">while</span>(error &amp;&amp; cmd1Retries -- &gt; 0);
<a name="l01319"></a>01319             <span class="keywordflow">if</span> (error) {
<a name="l01320"></a>01320                 TRACE_ERROR(<span class="stringliteral">&quot;SdMmcIdentify.Cmd1: %u\n\r&quot;</span>, error);
<a name="l01321"></a>01321                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01322"></a>01322             }
<a name="l01323"></a>01323             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ccs) pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> = CARD_MMCHD;
<a name="l01324"></a>01324             <span class="keywordflow">else</span>          pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> = CARD_MMC;
<a name="l01325"></a>01325             <span class="comment">/* MMC card identification OK */</span>
<a name="l01326"></a>01326             TRACE_INFO(<span class="stringliteral">&quot;MMC Card\n\r&quot;</span>);
<a name="l01327"></a>01327             <span class="keywordflow">return</span> 0;
<a name="l01328"></a>01328         }
<a name="l01329"></a>01329         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ccs) { TRACE_INFO(<span class="stringliteral">&quot;SDHC MEM\n\r&quot;</span>);}
<a name="l01330"></a>01330         <span class="keywordflow">else</span>          { TRACE_INFO(<span class="stringliteral">&quot;SD MEM\n\r&quot;</span>);}
<a name="l01331"></a>01331         mem = 1;
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333     <span class="comment">/* SD(IO) + MEM ? */</span>
<a name="l01334"></a>01334     <span class="keywordflow">if</span> (!mem) {
<a name="l01335"></a>01335         <span class="keywordflow">if</span> (io) pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> = CARD_SDIO;
<a name="l01336"></a>01336         <span class="keywordflow">else</span> {
<a name="l01337"></a>01337             TRACE_ERROR(<span class="stringliteral">&quot;Unknown card\n\r&quot;</span>);
<a name="l01338"></a>01338             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01339"></a>01339         }
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341     <span class="comment">/* SD(HC) combo */</span>
<a name="l01342"></a>01342     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io)
<a name="l01343"></a>01343         pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> = ccs ? <a class="code" href="group__sdmmc__cardtype.html#gac871c8b0d83c6c07000a3f4bf8aeb889">CARD_SDHCCOMBO</a> : CARD_SDCOMBO;
<a name="l01344"></a>01344     <span class="comment">/* SD(HC) */</span>
<a name="l01345"></a>01345     <span class="keywordflow">else</span>
<a name="l01346"></a>01346         pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> = ccs ? <a class="code" href="group__sdmmc__cardtype.html#ga08ec437adcd4a70a6d4804dfa3171086">CARD_SDHC</a> : CARD_SD;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348     <span class="keywordflow">return</span> 0;
<a name="l01349"></a>01349 }
<a name="l01350"></a>01350 <span class="comment"></span>
<a name="l01351"></a>01351 <span class="comment">/**</span>
<a name="l01352"></a>01352 <span class="comment"> * \brief Run the SD/MMC/SDIO enumeration sequence.</span>
<a name="l01353"></a>01353 <span class="comment"> * This function runs after the initialization and identification procedure. It</span>
<a name="l01354"></a>01354 <span class="comment"> * gets all necessary information from the card and deside transfer block size,</span>
<a name="l01355"></a>01355 <span class="comment"> * clock speed and bus width. It sets the SD/MMC/SDIO card in transfer</span>
<a name="l01356"></a>01356 <span class="comment"> * (or command) state.</span>
<a name="l01357"></a>01357 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01358"></a>01358 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;SD_ERROR code&quot;.</span>
<a name="l01359"></a>01359 <span class="comment"> */</span>
<a name="l01360"></a>01360 <span class="keyword">static</span> uint8_t SdMmcEnum(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01361"></a>01361 {
<a name="l01362"></a>01362     uint8_t mem , io;
<a name="l01363"></a>01363     uint8_t error;
<a name="l01364"></a>01364     uint32_t ioSpeed = 0, memSpeed = 0;
<a name="l01365"></a>01365     uint8_t hsExec = 0, bwExec = 0;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367     <span class="comment">/* - has Memory/IO/High-Capacigy - */</span>
<a name="l01368"></a>01368     mem = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDMMC) &gt; 0);
<a name="l01369"></a>01369     io  = ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; CARD_TYPE_bmSDIO)  &gt; 0);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="comment">/* For MEMORY cards:</span>
<a name="l01372"></a>01372 <span class="comment">     * The host then issues the command ALL_SEND_CID (CMD2) to the card to get</span>
<a name="l01373"></a>01373 <span class="comment">     * its unique card identification (CID) number.</span>
<a name="l01374"></a>01374 <span class="comment">     * Card that is unidentified (i.e. which is in Ready State) sends its CID</span>
<a name="l01375"></a>01375 <span class="comment">     * number as the response (on the CMD line). */</span>
<a name="l01376"></a>01376     <span class="keywordflow">if</span> (mem) {
<a name="l01377"></a>01377         error = Cmd2(pSd);
<a name="l01378"></a>01378         <span class="keywordflow">if</span> (error) {
<a name="l01379"></a>01379             TRACE_ERROR(<span class="stringliteral">&quot;SdMmcInit.cmd2(%d)\n\r&quot;</span>, error);
<a name="l01380"></a>01380             <span class="keywordflow">return</span> error;
<a name="l01381"></a>01381         }
<a name="l01382"></a>01382     }
<a name="l01383"></a>01383 
<a name="l01384"></a>01384     <span class="comment">/* For MEMORY and SDIO cards:</span>
<a name="l01385"></a>01385 <span class="comment">     * Thereafter, the host issues CMD3 (SEND_RELATIVE_ADDR) asks the</span>
<a name="l01386"></a>01386 <span class="comment">     * card to publish a new relative card address (RCA), which is shorter than</span>
<a name="l01387"></a>01387 <span class="comment">     * CID and which is used to address the card in the future data transfer</span>
<a name="l01388"></a>01388 <span class="comment">     * mode. Once the RCA is received the card state changes to the Stand-by</span>
<a name="l01389"></a>01389 <span class="comment">     * State. At this point, if the host wants to assign another RCA number, it</span>
<a name="l01390"></a>01390 <span class="comment">     * can ask the card to publish a new number by sending another CMD3 command</span>
<a name="l01391"></a>01391 <span class="comment">     * to the card. The last published RCA is the actual RCA number of the</span>
<a name="l01392"></a>01392 <span class="comment">     * card. */</span>
<a name="l01393"></a>01393     error = Cmd3(pSd);
<a name="l01394"></a>01394     <span class="keywordflow">if</span> (error) {
<a name="l01395"></a>01395         TRACE_ERROR(<span class="stringliteral">&quot;SdMmcInit.cmd3(%d)\n\r&quot;</span>, error);
<a name="l01396"></a>01396         <span class="keywordflow">return</span> error;
<a name="l01397"></a>01397     }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399     <span class="comment">/* For MEMORY cards:</span>
<a name="l01400"></a>01400 <span class="comment">     * SEND_CSD (CMD9) to obtain the Card Specific Data (CSD register),</span>
<a name="l01401"></a>01401 <span class="comment">     * e.g. block length, card storage capacity, etc... */</span>
<a name="l01402"></a>01402     <span class="keywordflow">if</span> (mem) {
<a name="l01403"></a>01403         error = Cmd9(pSd);
<a name="l01404"></a>01404         <span class="keywordflow">if</span> (error) {
<a name="l01405"></a>01405             TRACE_ERROR(<span class="stringliteral">&quot;SdMmcInit.cmd9(%d)\n\r&quot;</span>, error);
<a name="l01406"></a>01406             <span class="keywordflow">return</span> error;
<a name="l01407"></a>01407         }
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="comment">/* Now select the card, to TRAN state */</span>
<a name="l01411"></a>01411     error = MmcSelectCard(pSd, pSd-&gt;<a class="code" href="struct_sd_card.html#a922af00ff450d07074262014f01429a0">cardAddress</a>, 0);
<a name="l01412"></a>01412     <span class="keywordflow">if</span> (error) {
<a name="l01413"></a>01413         TRACE_ERROR(<span class="stringliteral">&quot;SdMmcInit.SelCard(%d)\n\r&quot;</span>, error);
<a name="l01414"></a>01414         <span class="keywordflow">return</span> error;
<a name="l01415"></a>01415     }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417     <span class="comment">/* - Now in TRAN, obtain extended setup information - */</span>
<a name="l01418"></a>01418 
<a name="l01419"></a>01419     <span class="comment">/* If the card support EXT_CSD, read it! */</span>
<a name="l01420"></a>01420     TRACE_INFO(<span class="stringliteral">&quot;Card Type %d, CSD_STRUCTURE %d\n\r&quot;</span>,
<a name="l01421"></a>01421                pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a>, <a class="code" href="group__sdmmc__mem__api.html#gad82fdd0c4e9da984885df36992db6612" title="CSD structure 00b Version 1.0 01b version 2.0 High Cap.">SD_CSD_STRUCTURE</a>(pSd));
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <span class="comment">/* Get extended information of the card */</span>
<a name="l01424"></a>01424     SdMmcUpdateInformation(pSd, 0, 1);
<a name="l01425"></a>01425 
<a name="l01426"></a>01426     <span class="comment">/* Calculate transfer speed */</span>
<a name="l01427"></a>01427     <span class="keywordflow">if</span> (io)     ioSpeed = SdioGetMaxSpeed(pSd);
<a name="l01428"></a>01428     <span class="keywordflow">if</span> (mem)    memSpeed = SdmmcGetMaxSpeed(pSd);
<a name="l01429"></a>01429     <span class="comment">/* Combo, min speed */</span>
<a name="l01430"></a>01430     <span class="keywordflow">if</span> (io &amp;&amp; mem) {
<a name="l01431"></a>01431         pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> = (ioSpeed &gt; memSpeed) ? memSpeed : ioSpeed;
<a name="l01432"></a>01432     }
<a name="l01433"></a>01433     <span class="comment">/* SDIO only */</span>
<a name="l01434"></a>01434     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io) {
<a name="l01435"></a>01435         pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> = ioSpeed;
<a name="l01436"></a>01436     }
<a name="l01437"></a>01437     <span class="comment">/* Memory card only */</span>
<a name="l01438"></a>01438     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mem) {
<a name="l01439"></a>01439         pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> = memSpeed;
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441     pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> *= 1000;
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     <span class="comment">/* Enable more bus width Mode */</span>
<a name="l01444"></a>01444     error = SdMmcDesideBuswidth(pSd);
<a name="l01445"></a>01445     <span class="keywordflow">if</span> (!error) bwExec = 1;
<a name="l01446"></a>01446     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error != <a class="code" href="group__sdmmc__rc.html#ga28504922db488cf77295f0da98ddf87a">SDMMC_ERROR_NOT_SUPPORT</a>) {
<a name="l01447"></a>01447         TRACE_ERROR(<span class="stringliteral">&quot;SdmmcEnum.DesideBusWidth: %u\n\r&quot;</span>, error);
<a name="l01448"></a>01448         <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01449"></a>01449     }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     <span class="comment">/* Enable High-Speed Mode */</span>
<a name="l01452"></a>01452     error = SdMmcEnableHighSpeed(pSd);
<a name="l01453"></a>01453     <span class="keywordflow">if</span> (!error) hsExec = 1;
<a name="l01454"></a>01454     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error != <a class="code" href="group__sdmmc__rc.html#ga28504922db488cf77295f0da98ddf87a">SDMMC_ERROR_NOT_SUPPORT</a>) {
<a name="l01455"></a>01455         TRACE_ERROR(<span class="stringliteral">&quot;SdmmcEnum.EnableHS: %u\n\r&quot;</span>, error);
<a name="l01456"></a>01456         <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     <span class="comment">/* In HS mode transfer speed *2 */</span>
<a name="l01460"></a>01460     <span class="keywordflow">if</span> (hsExec) pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> *= 2;
<a name="l01461"></a>01461 
<a name="l01462"></a>01462     <span class="comment">/* Update card information since status changed */</span>
<a name="l01463"></a>01463     <span class="keywordflow">if</span> (bwExec || hsExec) SdMmcUpdateInformation(pSd, hsExec, 1);
<a name="l01464"></a>01464     <span class="keywordflow">return</span> 0;
<a name="l01465"></a>01465 }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 <span class="comment">/*----------------------------------------------------------------------------</span>
<a name="l01468"></a>01468 <span class="comment"> *         Global functions</span>
<a name="l01469"></a>01469 <span class="comment"> *----------------------------------------------------------------------------*/</span>
<a name="l01470"></a>01470 <span class="comment"></span>
<a name="l01471"></a>01471 <span class="comment">/**</span>
<a name="l01472"></a>01472 <span class="comment"> * Read Blocks of data in a buffer pointed by pData. The buffer size must be at</span>
<a name="l01473"></a>01473 <span class="comment"> * least 512 byte long. This function checks the SD card status register and</span>
<a name="l01474"></a>01474 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01475"></a>01475 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01476"></a>01476 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l01477"></a>01477 <span class="comment"> * \param address  Address of the block to read.</span>
<a name="l01478"></a>01478 <span class="comment"> * \param pData    Data buffer whose size is at least the block size, it can</span>
<a name="l01479"></a>01479 <span class="comment"> *            be 1,2 or 4-bytes aligned when used with DMA.</span>
<a name="l01480"></a>01480 <span class="comment"> * \param length   Number of blocks to be read.</span>
<a name="l01481"></a>01481 <span class="comment"> * \param pCallback Pointer to callback function that invoked when read done.</span>
<a name="l01482"></a>01482 <span class="comment"> *                  0 to start a blocked read.</span>
<a name="l01483"></a>01483 <span class="comment"> * \param pArgs     Pointer to callback function arguments.</span>
<a name="l01484"></a>01484 <span class="comment"> */</span>
<a name="l01485"></a><a class="code" href="group__sdmmc__api.html#gae7468537f47e1d55d9e90c89cbb10272">01485</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#gae7468537f47e1d55d9e90c89cbb10272">SD_Read</a>(<a class="code" href="struct_sd_card.html">SdCard</a>        *pSd,
<a name="l01486"></a>01486                 uint32_t      address,
<a name="l01487"></a>01487                 <span class="keywordtype">void</span>          *pData,
<a name="l01488"></a>01488                 uint16_t      length,
<a name="l01489"></a>01489                 <a class="code" href="group__sdmmc__hal.html#gae854df62b67725efa2e97f8ea868abd2">SdmmcCallback</a> pCallback,
<a name="l01490"></a>01490                 <span class="keywordtype">void</span>          *pArgs)
<a name="l01491"></a>01491 {
<a name="l01492"></a>01492     uint8_t error;
<a name="l01493"></a>01493 
<a name="l01494"></a>01494     assert( pSd != NULL ) ;
<a name="l01495"></a>01495     assert( pData != NULL ) ;
<a name="l01496"></a>01496 
<a name="l01497"></a>01497     <span class="keywordflow">if</span> (   pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> != SD_STATE_READ
<a name="l01498"></a>01498         || pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> + 1 != address ) {
<a name="l01499"></a>01499         <span class="comment">/* Start infinite block reading */</span>
<a name="l01500"></a>01500         error = MoveToTransferState(pSd, address, 0, 0, 1);
<a name="l01501"></a>01501     }
<a name="l01502"></a>01502     <span class="keywordflow">else</span>    error = 0;
<a name="l01503"></a>01503     <span class="keywordflow">if</span> (!error) {
<a name="l01504"></a>01504         pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> = SD_STATE_READ;
<a name="l01505"></a>01505         pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> = address + (length - 1);
<a name="l01506"></a>01506         error = <a class="code" href="group__sdmmc__hal.html#ga9819d6bb1be7694a1f852c7b8dd7024c">SdmmcRead</a>(pSd, <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), length, pData,
<a name="l01507"></a>01507                           pCallback, pArgs);
<a name="l01508"></a>01508     }
<a name="l01509"></a>01509     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SDrd(%u,%u):%u\n\r&quot;</span>, address, length, error);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511     <span class="keywordflow">return</span> 0;
<a name="l01512"></a>01512 }
<a name="l01513"></a>01513 <span class="comment"></span>
<a name="l01514"></a>01514 <span class="comment">/**</span>
<a name="l01515"></a>01515 <span class="comment"> * Write Blocks of data in a buffer pointed by pData. The buffer size must be at</span>
<a name="l01516"></a>01516 <span class="comment"> * least 512 byte long. This function checks the SD card status register and</span>
<a name="l01517"></a>01517 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01518"></a>01518 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01519"></a>01519 <span class="comment"> * \param pSd      Pointer to a SD card driver instance.</span>
<a name="l01520"></a>01520 <span class="comment"> * \param address  Address of the block to read.</span>
<a name="l01521"></a>01521 <span class="comment"> * \param pData    Data buffer whose size is at least the block size, it can</span>
<a name="l01522"></a>01522 <span class="comment"> *            be 1,2 or 4-bytes aligned when used with DMA.</span>
<a name="l01523"></a>01523 <span class="comment"> * \param length   Number of blocks to be read.</span>
<a name="l01524"></a>01524 <span class="comment"> * \param pCallback Pointer to callback function that invoked when read done.</span>
<a name="l01525"></a>01525 <span class="comment"> *                  0 to start a blocked read.</span>
<a name="l01526"></a>01526 <span class="comment"> * \param pArgs     Pointer to callback function arguments.</span>
<a name="l01527"></a>01527 <span class="comment"> */</span>
<a name="l01528"></a><a class="code" href="group__sdmmc__api.html#ga4460f649632cd04aee01b2df2c4a1284">01528</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga4460f649632cd04aee01b2df2c4a1284">SD_Write</a>(<a class="code" href="struct_sd_card.html">SdCard</a>        *pSd,
<a name="l01529"></a>01529                  uint32_t      address,
<a name="l01530"></a>01530                  <span class="keywordtype">void</span>          *pData,
<a name="l01531"></a>01531                  uint16_t      length,
<a name="l01532"></a>01532                  <a class="code" href="group__sdmmc__hal.html#gae854df62b67725efa2e97f8ea868abd2">SdmmcCallback</a> pCallback,
<a name="l01533"></a>01533                  <span class="keywordtype">void</span>          *pArgs)
<a name="l01534"></a>01534 {
<a name="l01535"></a>01535     uint8_t error = 0;
<a name="l01536"></a>01536 
<a name="l01537"></a>01537     assert( pSd != NULL ) ;
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     <span class="keywordflow">if</span> (   pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> != SD_STATE_WRITE
<a name="l01540"></a>01540         || pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> + 1 != address ) {
<a name="l01541"></a>01541         <span class="comment">/* Start infinite block writing */</span>
<a name="l01542"></a>01542         error = MoveToTransferState(pSd, address, 0, 0, 0);
<a name="l01543"></a>01543     }
<a name="l01544"></a>01544     <span class="keywordflow">if</span> (!error) {
<a name="l01545"></a>01545         pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> = SD_STATE_WRITE;
<a name="l01546"></a>01546         error = <a class="code" href="group__sdmmc__hal.html#ga02b725cbcbdb88db2391f0b9a36ec637">SdmmcWrite</a>(pSd, <a class="code" href="group__sdmmc__api.html#gae8d27d6bb7106251d454a6ea27698fec">BLOCK_SIZE</a>(pSd), length, pData,
<a name="l01547"></a>01547                            pCallback, pArgs);
<a name="l01548"></a>01548         pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a> = address + (length - 1);
<a name="l01549"></a>01549     }
<a name="l01550"></a>01550     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;SDwr(%u,%u):%u\n\r&quot;</span>, address, length, error);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552     <span class="keywordflow">return</span> 0;
<a name="l01553"></a>01553 }
<a name="l01554"></a>01554 <span class="comment"></span>
<a name="l01555"></a>01555 <span class="comment">/**</span>
<a name="l01556"></a>01556 <span class="comment"> * Read 1 Block of data in a buffer pointed by pData. The buffer size must be</span>
<a name="l01557"></a>01557 <span class="comment"> * one block size. This function checks the SD card status register and</span>
<a name="l01558"></a>01558 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01559"></a>01559 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01560"></a>01560 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01561"></a>01561 <span class="comment"> * \param address  Address of the block to read.</span>
<a name="l01562"></a>01562 <span class="comment"> * \param pData    Data buffer whose size is at least the block size.</span>
<a name="l01563"></a>01563 <span class="comment"> */</span>
<a name="l01564"></a><a class="code" href="group__sdmmc__api.html#gabaf441265ae3115979104a1116b5449a">01564</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#gabaf441265ae3115979104a1116b5449a">SD_ReadBlock</a>( <a class="code" href="struct_sd_card.html">SdCard</a> *pSd, uint32_t address, uint8_t *pData )
<a name="l01565"></a>01565 {
<a name="l01566"></a>01566     assert( pSd != NULL ) ;
<a name="l01567"></a>01567     assert( pData != NULL ) ;
<a name="l01568"></a>01568 
<a name="l01569"></a>01569     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;RdBlk(%d)\n\r&quot;</span>, address);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571     <span class="keywordflow">return</span> PerformSingleTransfer(pSd, address, pData, 1);
<a name="l01572"></a>01572 }
<a name="l01573"></a>01573 <span class="comment"></span>
<a name="l01574"></a>01574 <span class="comment">/**</span>
<a name="l01575"></a>01575 <span class="comment"> * Write 1 Block of data pointed by pData. The buffer size must be</span>
<a name="l01576"></a>01576 <span class="comment"> * one block size. This function checks the SD card status register and</span>
<a name="l01577"></a>01577 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01578"></a>01578 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01579"></a>01579 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01580"></a>01580 <span class="comment"> * \param address  Address of block to write.</span>
<a name="l01581"></a>01581 <span class="comment"> * \param pData    Data buffer whose size is at least the block size, it can</span>
<a name="l01582"></a>01582 <span class="comment"> *                 be 1,2 or 4-bytes aligned when used with DMA.</span>
<a name="l01583"></a>01583 <span class="comment"> */</span>
<a name="l01584"></a><a class="code" href="group__sdmmc__api.html#ga1b730b57053186a441d5061c5bfd6fc5">01584</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga1b730b57053186a441d5061c5bfd6fc5">SD_WriteBlock</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01585"></a>01585                       uint32_t address,
<a name="l01586"></a>01586                       uint8_t *pData)
<a name="l01587"></a>01587 {
<a name="l01588"></a>01588     assert( pSd != NULL ) ;
<a name="l01589"></a>01589     assert( pData != NULL ) ;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;WrBlk(%d)\n\r&quot;</span>, address);
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <span class="keywordflow">return</span> PerformSingleTransfer(pSd, address, pData, 0);
<a name="l01594"></a>01594 }
<a name="l01595"></a>01595 <span class="comment"></span>
<a name="l01596"></a>01596 <span class="comment">/**</span>
<a name="l01597"></a>01597 <span class="comment"> * Read Blocks of data in a buffer pointed by pData. The buffer size must be at</span>
<a name="l01598"></a>01598 <span class="comment"> * least 512 byte long. This function checks the SD card status register and</span>
<a name="l01599"></a>01599 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01600"></a>01600 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01601"></a>01601 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01602"></a>01602 <span class="comment"> * \param address  Address of the block to read.</span>
<a name="l01603"></a>01603 <span class="comment"> * \param nbBlocks Number of blocks to be read.</span>
<a name="l01604"></a>01604 <span class="comment"> * \param pData    Data buffer whose size is at least the block size, it can</span>
<a name="l01605"></a>01605 <span class="comment"> *            be 1,2 or 4-bytes aligned when used with DMA.</span>
<a name="l01606"></a>01606 <span class="comment"> */</span>
<a name="l01607"></a><a class="code" href="group__sdmmc__api.html#ga861571b15bc896574006eee0042e6d71">01607</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga861571b15bc896574006eee0042e6d71">SD_ReadBlocks</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01608"></a>01608                       uint32_t address,
<a name="l01609"></a>01609                       uint16_t nbBlocks,
<a name="l01610"></a>01610                       uint8_t *pData)
<a name="l01611"></a>01611 {
<a name="l01612"></a>01612     uint8_t error = 0;
<a name="l01613"></a>01613 
<a name="l01614"></a>01614     assert( pSd != NULL ) ;
<a name="l01615"></a>01615     assert( pData != NULL ) ;
<a name="l01616"></a>01616     assert( nbBlocks != NULL ) ;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;RdBlks(%d,%d)\n\r&quot;</span>, address, nbBlocks);
<a name="l01619"></a>01619     <span class="keywordflow">while</span>(nbBlocks --) {
<a name="l01620"></a>01620         error = PerformSingleTransfer(pSd, address, pData, 1);
<a name="l01621"></a>01621         <span class="keywordflow">if</span> (error)
<a name="l01622"></a>01622             <span class="keywordflow">break</span>;
<a name="l01623"></a>01623         address += 1;
<a name="l01624"></a>01624         pData = &amp;pData[512];
<a name="l01625"></a>01625     }
<a name="l01626"></a>01626     <span class="keywordflow">return</span> error;
<a name="l01627"></a>01627 }
<a name="l01628"></a>01628 <span class="comment"></span>
<a name="l01629"></a>01629 <span class="comment">/**</span>
<a name="l01630"></a>01630 <span class="comment"> * Write Block of data pointed by pData. The buffer size must be at</span>
<a name="l01631"></a>01631 <span class="comment"> * least 512 byte long. This function checks the SD card status register and</span>
<a name="l01632"></a>01632 <span class="comment"> * address the card if required before sending the read command.</span>
<a name="l01633"></a>01633 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01634"></a>01634 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01635"></a>01635 <span class="comment"> * \param address  Address of block to write.</span>
<a name="l01636"></a>01636 <span class="comment"> * \param nbBlocks Number of blocks to be read</span>
<a name="l01637"></a>01637 <span class="comment"> * \param pData    Data buffer whose size is at least the block size, it can</span>
<a name="l01638"></a>01638 <span class="comment"> *            be 1,2 or 4-bytes aligned when used with DMA.</span>
<a name="l01639"></a>01639 <span class="comment"> */</span>
<a name="l01640"></a><a class="code" href="group__sdmmc__api.html#ga9b7a6954fabd651396d10ec97cb3f828">01640</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga9b7a6954fabd651396d10ec97cb3f828">SD_WriteBlocks</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01641"></a>01641                        uint32_t address,
<a name="l01642"></a>01642                        uint16_t nbBlocks,
<a name="l01643"></a>01643                        uint8_t *pData)
<a name="l01644"></a>01644 {
<a name="l01645"></a>01645     uint8_t error = 0;
<a name="l01646"></a>01646     uint8_t *pB = (uint8_t*)pData;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     assert( pSd != NULL ) ;
<a name="l01649"></a>01649     assert( pData != NULL ) ;
<a name="l01650"></a>01650     assert( nbBlocks != NULL ) ;
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;WrBlks(%d,%d)\n\r&quot;</span>, address, nbBlocks);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654     <span class="keywordflow">while</span>(nbBlocks --) {
<a name="l01655"></a>01655         error = PerformSingleTransfer(pSd, address, pB, 0);
<a name="l01656"></a>01656         <span class="keywordflow">if</span> (error)
<a name="l01657"></a>01657             <span class="keywordflow">break</span>;
<a name="l01658"></a>01658         address += 1;
<a name="l01659"></a>01659         pB = &amp;pB[512];
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661     <span class="keywordflow">return</span> error;
<a name="l01662"></a>01662 }
<a name="l01663"></a>01663 <span class="comment"></span>
<a name="l01664"></a>01664 <span class="comment">/**</span>
<a name="l01665"></a>01665 <span class="comment"> * Run the SDcard initialization sequence. This function runs the</span>
<a name="l01666"></a>01666 <span class="comment"> * initialisation procedure and the identification process, then it sets the</span>
<a name="l01667"></a>01667 <span class="comment"> * SD card in transfer state to set the block length and the bus width.</span>
<a name="l01668"></a>01668 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01669"></a>01669 <span class="comment"> * \param pSd  Pointer to a SD card driver instance.</span>
<a name="l01670"></a>01670 <span class="comment"> * \param pSdDriver  Pointer to SD driver already initialized.</span>
<a name="l01671"></a>01671 <span class="comment"> */</span>
<a name="l01672"></a><a class="code" href="group__sdmmc__api.html#gab78e0bf408ec9740530137e21f2dc534">01672</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#gab78e0bf408ec9740530137e21f2dc534">SD_Init</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd, <span class="keywordtype">void</span> *pSdDriver)
<a name="l01673"></a>01673 {
<a name="l01674"></a>01674     uint8_t  error;
<a name="l01675"></a>01675     uint32_t clock;
<a name="l01676"></a>01676     uint32_t i;
<a name="l01677"></a>01677 
<a name="l01678"></a>01678     <span class="comment">/* Initialize SdCard structure */</span>
<a name="l01679"></a>01679     pSd-&gt;<a class="code" href="struct_sd_card.html#aa75dc1a29e48ce4aab04c89597d68db7">pSdDriver</a> = pSdDriver;
<a name="l01680"></a>01680 
<a name="l01681"></a>01681     pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a> = 0;
<a name="l01682"></a>01682     pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a>  = 0;
<a name="l01683"></a>01683     pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a>    = 0;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685     pSd-&gt;<a class="code" href="struct_sd_card.html#ab34fc4b5943d8bf281a8df6504ab0c92">preBlock</a>     = 0xffffffff;
<a name="l01686"></a>01686     pSd-&gt;<a class="code" href="struct_sd_card.html#aab58ab224ab7bcdd88f4623105816546">optCmdBitMap</a> = 0xFFFFFFFF;
<a name="l01687"></a>01687 
<a name="l01688"></a>01688     pSd-&gt;<a class="code" href="struct_sd_card.html#a38cc103e5752ce9aa342de33d5a0885b">accSpeed</a>    = 0;
<a name="l01689"></a>01689     pSd-&gt;<a class="code" href="struct_sd_card.html#a922af00ff450d07074262014f01429a0">cardAddress</a> = 0;
<a name="l01690"></a>01690     pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a>    = CARD_UNKNOWN;
<a name="l01691"></a>01691     pSd-&gt;<a class="code" href="struct_sd_card.html#a87793f6807f0e11c618e55c38a0b5839">busMode</a>     = 0;
<a name="l01692"></a>01692     pSd-&gt;<a class="code" href="struct_sd_card.html#a725642405b5b54a2c5a468fea5d94527">cardSlot</a>    = 0;
<a name="l01693"></a>01693     pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a>       = SD_STATE_INIT;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     <span class="comment">/* Clear CID, CSD, EXT_CSD data */</span>
<a name="l01696"></a>01696     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++)     pSd-&gt;<a class="code" href="struct_sd_card.html#a67164158219a672d9b784023befe962b">cid</a>[i] = 0;
<a name="l01697"></a>01697     for (i = 0; i &lt; 4; i ++)     pSd-&gt;<a class="code" href="struct_sd_card.html#ac4754276c96ab4d9a7ca9757efd4cf37">csd</a>[i] = 0;
<a name="l01698"></a>01698     for (i = 0; i &lt; 512/4; i ++) pSd-&gt;<a class="code" href="struct_sd_card.html#a6605007bdc7d2cb6d440e3b57f3485d2">extData</a>[i] = 0;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700     <span class="comment">/* Set low speed for device identification (LS device max speed) */</span>
<a name="l01701"></a>01701     <a class="code" href="group__sdmmc__hal.html#gae3c0796466bb57d4943936ec34113b11">SdmmcSetSpeed</a>(pSd, 400000);
<a name="l01702"></a>01702 
<a name="l01703"></a>01703     <span class="comment">/* Initialization delay: The maximum of 1 msec, 74 clock cycles and supply</span>
<a name="l01704"></a>01704 <span class="comment">     * ramp up time. Supply ramp up time provides the time that the power is</span>
<a name="l01705"></a>01705 <span class="comment">     * built up to the operating level (the bus master supply voltage) and the</span>
<a name="l01706"></a>01706 <span class="comment">     * time to wait until the SD card can accept the first command. */</span>
<a name="l01707"></a>01707     <span class="comment">/* Power On Init Special Command */</span>
<a name="l01708"></a>01708     error = Pon(pSd);
<a name="l01709"></a>01709     <span class="keywordflow">if</span> (error) {
<a name="l01710"></a>01710         TRACE_ERROR(<span class="stringliteral">&quot;SD_Init.PowON:%d\n\r&quot;</span>, error);
<a name="l01711"></a>01711         <span class="keywordflow">return</span> error;
<a name="l01712"></a>01712     }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714     <span class="comment">/* After power-on or CMD0, all cards?</span>
<a name="l01715"></a>01715 <span class="comment">     * CMD lines are in input mode, waiting for start bit of the next command.</span>
<a name="l01716"></a>01716 <span class="comment">     * The cards are initialized with a default relative card address</span>
<a name="l01717"></a>01717 <span class="comment">     * (RCA=0x0000) and with a default driver stage register setting</span>
<a name="l01718"></a>01718 <span class="comment">     * (lowest speed, highest driving current capability). */</span>
<a name="l01719"></a>01719     error = SdMmcIdentify(pSd);
<a name="l01720"></a>01720     <span class="keywordflow">if</span> (error) {
<a name="l01721"></a>01721         TRACE_ERROR(<span class="stringliteral">&quot;SD_Init.Identify: %u\n\r&quot;</span>, error);
<a name="l01722"></a>01722         <span class="keywordflow">return</span> error;
<a name="l01723"></a>01723     }
<a name="l01724"></a>01724     error = SdMmcEnum(pSd);
<a name="l01725"></a>01725     <span class="keywordflow">if</span> (error) {
<a name="l01726"></a>01726         TRACE_ERROR(<span class="stringliteral">&quot;SD_Init.Enum: %u\n\r&quot;</span>, error);
<a name="l01727"></a>01727         <span class="keywordflow">return</span> error;
<a name="l01728"></a>01728     }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     <span class="comment">/* In the case of a Standard Capacity SD Memory Card, this command sets the</span>
<a name="l01731"></a>01731 <span class="comment">     * block length (in bytes) for all following block commands</span>
<a name="l01732"></a>01732 <span class="comment">     * (read, write, lock).</span>
<a name="l01733"></a>01733 <span class="comment">     * Default block length is fixed to 512 Bytes.</span>
<a name="l01734"></a>01734 <span class="comment">     * Set length is valid for memory access commands only if partial block read</span>
<a name="l01735"></a>01735 <span class="comment">     * operation are allowed in CSD.</span>
<a name="l01736"></a>01736 <span class="comment">     * In the case of a High Capacity SD Memory Card, block length set by CMD16</span>
<a name="l01737"></a>01737 <span class="comment">     * command does not affect the memory read and write commands. Always 512</span>
<a name="l01738"></a>01738 <span class="comment">     * Bytes fixed block length is used. This command is effective for</span>
<a name="l01739"></a>01739 <span class="comment">     * LOCK_UNLOCK command.</span>
<a name="l01740"></a>01740 <span class="comment">     * In both cases, if block length is set larger than 512Bytes, the card sets</span>
<a name="l01741"></a>01741 <span class="comment">     * the BLOCK_LEN_ERROR bit. */</span>
<a name="l01742"></a>01742     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> == <a class="code" href="group__sdmmc__cardtype.html#ga5f88e605935067b9dccd47b5ab2994e8">CARD_SD</a>) {
<a name="l01743"></a>01743         error = Cmd16(pSd, <a class="code" href="group__sdmmc__hal.html#ga02a20e1220e3a4fa2d9ea31454a3670c">SDMMC_BLOCK_SIZE</a>);
<a name="l01744"></a>01744         <span class="keywordflow">if</span> (error) {
<a name="l01745"></a>01745             pSd-&gt;<a class="code" href="struct_sd_card.html#aab58ab224ab7bcdd88f4623105816546">optCmdBitMap</a> &amp;= ~SD_CMD16_SUPPORT;
<a name="l01746"></a>01746             TRACE_INFO(<span class="stringliteral">&quot;SD_Init.Cmd16 (%d)\n\r&quot;</span>, error);
<a name="l01747"></a>01747             TRACE_INFO(<span class="stringliteral">&quot;Fail to set BLK_LEN, default is 512\n\r&quot;</span>);
<a name="l01748"></a>01748         }
<a name="l01749"></a>01749     }
<a name="l01750"></a>01750 
<a name="l01751"></a>01751     <span class="comment">/* Reset status for R/W */</span>
<a name="l01752"></a>01752     pSd-&gt;<a class="code" href="struct_sd_card.html#aa04619892b5b632ac6b0136ae56d0233">state</a> = SD_STATE_READY;
<a name="l01753"></a>01753 
<a name="l01754"></a>01754     <span class="comment">/* If MMC Card &amp; get size from EXT_CSD */</span>
<a name="l01755"></a>01755     <span class="keywordflow">if</span> ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) == <a class="code" href="group__sdmmc__cardtype.html#ga31828db74f62996887d42d783d05d609">CARD_TYPE_bmMMC</a>
<a name="l01756"></a>01756         &amp;&amp; <a class="code" href="group__sdmmc__mem__api.html#ga2edf758ebc74506c8e2b2fee49e031fe" title="Device size.">SD_CSD_C_SIZE</a>(pSd) == 0xFFF) {
<a name="l01757"></a>01757         pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a> = SD_EXTCSD_BLOCKNR(pSd);
<a name="l01758"></a>01758         <span class="comment">/* Block number less than 0x100000000/512 */</span>
<a name="l01759"></a>01759         <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a> &gt; 0x800000)
<a name="l01760"></a>01760             pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> = 0xFFFFFFFF;
<a name="l01761"></a>01761         <span class="keywordflow">else</span>
<a name="l01762"></a>01762             pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> = SD_EXTCSD_TOTAL_SIZE(pSd);
<a name="l01763"></a>01763     }
<a name="l01764"></a>01764     <span class="comment">/* If SD CSD v2.0 */</span>
<a name="l01765"></a>01765     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) == <a class="code" href="group__sdmmc__cardtype.html#gaa6a8c3512b0026e1e1e868519c32ea5f">CARD_TYPE_bmSD</a>
<a name="l01766"></a>01766         &amp;&amp; <a class="code" href="group__sdmmc__mem__api.html#gad82fdd0c4e9da984885df36992db6612" title="CSD structure 00b Version 1.0 01b version 2.0 High Cap.">SD_CSD_STRUCTURE</a>(pSd) &gt;= 1) {
<a name="l01767"></a>01767         pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a>   = SD_CSD_BLOCKNR_HC(pSd);
<a name="l01768"></a>01768         pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> = 0xFFFFFFFF;
<a name="l01769"></a>01769     }
<a name="l01770"></a>01770     <span class="comment">/* Normal SD/MMC card */</span>
<a name="l01771"></a>01771     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) {
<a name="l01772"></a>01772         pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> = SD_CSD_TOTAL_SIZE(pSd);
<a name="l01773"></a>01773         pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a> = SD_CSD_BLOCKNR(pSd);
<a name="l01774"></a>01774     }
<a name="l01775"></a>01775 
<a name="l01776"></a>01776     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> == <a class="code" href="group__sdmmc__cardtype.html#ga2bcf7921ec4872d70667001a21fbe3b4">CARD_UNKNOWN</a>) {
<a name="l01777"></a>01777         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_INITIALIZED;
<a name="l01778"></a>01778     }
<a name="l01779"></a>01779     <span class="comment">/* Automatically select the max clock */</span>
<a name="l01780"></a>01780     clock = <a class="code" href="group__sdmmc__hal.html#gae3c0796466bb57d4943936ec34113b11">SdmmcSetSpeed</a>(pSd, pSd-&gt;<a class="code" href="struct_sd_card.html#a28406c05189e3c5f2cf427233576f3f1">transSpeed</a>);
<a name="l01781"></a>01781     TRACE_WARNING_WP(<span class="stringliteral">&quot;-I- Set SD/MMC clock to %dK\n\r&quot;</span>, clock/1000);
<a name="l01782"></a>01782     pSd-&gt;<a class="code" href="struct_sd_card.html#a38cc103e5752ce9aa342de33d5a0885b">accSpeed</a> = clock;
<a name="l01783"></a>01783     <span class="keywordflow">return</span> 0;
<a name="l01784"></a>01784 }
<a name="l01785"></a>01785 <span class="comment"></span>
<a name="l01786"></a>01786 <span class="comment">/**</span>
<a name="l01787"></a>01787 <span class="comment"> * Return type of the card.</span>
<a name="l01788"></a>01788 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l01789"></a>01789 <span class="comment"> * \sa sdmmc_cardtype</span>
<a name="l01790"></a>01790 <span class="comment"> */</span>
<a name="l01791"></a><a class="code" href="group__sdmmc__api.html#ga7f93f494ff86780964a82efcd1f3616b">01791</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga7f93f494ff86780964a82efcd1f3616b">SD_GetCardType</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01792"></a>01792 {
<a name="l01793"></a>01793     assert( pSd != NULL ) ;
<a name="l01794"></a>01794 
<a name="l01795"></a>01795     <span class="keywordflow">return</span> pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a>;
<a name="l01796"></a>01796 }
<a name="l01797"></a>01797 <span class="comment"></span>
<a name="l01798"></a>01798 <span class="comment">/**</span>
<a name="l01799"></a>01799 <span class="comment"> * Return size of the SD/MMC card, in KB.</span>
<a name="l01800"></a>01800 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l01801"></a>01801 <span class="comment"> */</span>
<a name="l01802"></a><a class="code" href="group__sdmmc__api.html#gadac0fbf421bed8fe7f2b63c1c30616d3">01802</a> uint32_t <a class="code" href="group__sdmmc__mem__api.html#gadac0fbf421bed8fe7f2b63c1c30616d3">SD_GetTotalSizeKB</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01803"></a>01803 {
<a name="l01804"></a>01804     assert( pSd != NULL ) ;
<a name="l01805"></a>01805 
<a name="l01806"></a>01806     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> == 0xFFFFFFFF) {
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         <span class="keywordflow">return</span> pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a> / 2;
<a name="l01809"></a>01809     }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811     <span class="keywordflow">return</span> pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> / 1024;
<a name="l01812"></a>01812 }
<a name="l01813"></a>01813 <span class="comment"></span>
<a name="l01814"></a>01814 <span class="comment">/**</span>
<a name="l01815"></a>01815 <span class="comment"> * Return reported block size of the SD/MMC card.</span>
<a name="l01816"></a>01816 <span class="comment"> * (SD/MMC access block size is always 512B for R/W).</span>
<a name="l01817"></a>01817 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l01818"></a>01818 <span class="comment"> */</span>
<a name="l01819"></a><a class="code" href="group__sdmmc__api.html#ga7311608c9a68818776a05ee7b7c1b104">01819</a> uint32_t <a class="code" href="group__sdmmc__mem__api.html#ga7311608c9a68818776a05ee7b7c1b104">SD_GetBlockSize</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l01820"></a>01820 {
<a name="l01821"></a>01821     assert( pSd != NULL ) ;
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a8423401ebfcdd49c9f641948fa6d4726">totalSize</a> == 0xFFFFFFFF)
<a name="l01824"></a>01824         <span class="keywordflow">return</span> 512;
<a name="l01825"></a>01825     <span class="keywordflow">else</span>
<a name="l01826"></a>01826         <span class="keywordflow">return</span> (SD_TOTAL_SIZE(pSd) / SD_TOTAL_BLOCK(pSd));
<a name="l01827"></a>01827 }
<a name="l01828"></a>01828 <span class="comment"></span>
<a name="l01829"></a>01829 <span class="comment">/**</span>
<a name="l01830"></a>01830 <span class="comment"> * Return reported number of blocks for the SD/MMC card.</span>
<a name="l01831"></a>01831 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l01832"></a>01832 <span class="comment"> */</span>
<a name="l01833"></a><a class="code" href="group__sdmmc__api.html#ga2010aeac151bdace937300e8b26b28e9">01833</a> uint32_t <a class="code" href="group__sdmmc__mem__api.html#ga2010aeac151bdace937300e8b26b28e9">SD_GetNumberBlocks</a>( <a class="code" href="struct_sd_card.html">SdCard</a> *pSd )
<a name="l01834"></a>01834 {
<a name="l01835"></a>01835     assert( pSd != NULL ) ;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837     <span class="keywordflow">return</span> pSd-&gt;<a class="code" href="struct_sd_card.html#a413087ade33891c979c75afd5ee449c4">blockNr</a> ;
<a name="l01838"></a>01838 }
<a name="l01839"></a>01839 <span class="comment"></span>
<a name="l01840"></a>01840 <span class="comment">/**</span>
<a name="l01841"></a>01841 <span class="comment"> * Read one or more bytes from SDIO card, using RW_DIRECT command.</span>
<a name="l01842"></a>01842 <span class="comment"> * \param pSd         Pointer to SdCard instance.</span>
<a name="l01843"></a>01843 <span class="comment"> * \param functionNum Function number.</span>
<a name="l01844"></a>01844 <span class="comment"> * \param address     First register address to read from.</span>
<a name="l01845"></a>01845 <span class="comment"> * \param pData       Pointer to data buffer.</span>
<a name="l01846"></a>01846 <span class="comment"> * \param size        Buffer size, number of bytes to read.</span>
<a name="l01847"></a>01847 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01848"></a>01848 <span class="comment"> */</span>
<a name="l01849"></a><a class="code" href="group__sdmmc__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">01849</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01850"></a>01850                         uint8_t functionNum,
<a name="l01851"></a>01851                         uint32_t address,
<a name="l01852"></a>01852                         uint8_t *pData,
<a name="l01853"></a>01853                         uint32_t size)
<a name="l01854"></a>01854 {
<a name="l01855"></a>01855     uint8_t  error;
<a name="l01856"></a>01856     uint32_t status;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858     assert( pSd != NULL ) ;
<a name="l01859"></a>01859 
<a name="l01860"></a>01860     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga0881e572c2c166e60e7f050546277405">CARD_TYPE_bmSDIO</a>) {
<a name="l01861"></a>01861         <span class="keywordflow">if</span> (size == 0) <span class="keywordflow">return</span> SDMMC_ERROR_PARAM;
<a name="l01862"></a>01862         <span class="keywordflow">while</span>(size --) {
<a name="l01863"></a>01863             status = 0;
<a name="l01864"></a>01864             error = Cmd52(pSd, 0, functionNum, 0, address ++, &amp;status);
<a name="l01865"></a>01865             <span class="keywordflow">if</span> (pData) *pData ++ = (uint8_t)status;
<a name="l01866"></a>01866             <span class="keywordflow">if</span> (error) {
<a name="l01867"></a>01867                 TRACE_ERROR(<span class="stringliteral">&quot;IO_RdDirect.Cmd52: %u\n\r&quot;</span>, error);
<a name="l01868"></a>01868                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01869"></a>01869             }
<a name="l01870"></a>01870             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; STATUS_SDIO_R5) {
<a name="l01871"></a>01871                 TRACE_ERROR(<span class="stringliteral">&quot;RD_DIRECT(%u, %u) st %x\n\r&quot;</span>,
<a name="l01872"></a>01872                     address, size, status);
<a name="l01873"></a>01873                 <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01874"></a>01874             }
<a name="l01875"></a>01875         }
<a name="l01876"></a>01876     }
<a name="l01877"></a>01877     <span class="keywordflow">else</span> {
<a name="l01878"></a>01878         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01879"></a>01879     }
<a name="l01880"></a>01880     <span class="keywordflow">return</span> 0;
<a name="l01881"></a>01881 }
<a name="l01882"></a>01882 <span class="comment"></span>
<a name="l01883"></a>01883 <span class="comment">/**</span>
<a name="l01884"></a>01884 <span class="comment"> * Write one byte to SDIO card, using RW_DIRECT command.</span>
<a name="l01885"></a>01885 <span class="comment"> * \param pSd         Pointer to SdCard instance.</span>
<a name="l01886"></a>01886 <span class="comment"> * \param functionNum Function number.</span>
<a name="l01887"></a>01887 <span class="comment"> * \param address     Register address to write to.</span>
<a name="l01888"></a>01888 <span class="comment"> * \param dataByte    Data to write.</span>
<a name="l01889"></a>01889 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01890"></a>01890 <span class="comment"> */</span>
<a name="l01891"></a><a class="code" href="group__sdmmc__api.html#ga043aa423174ebe49da0524918778c7db">01891</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga043aa423174ebe49da0524918778c7db">SDIO_WriteDirect</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01892"></a>01892                          uint8_t functionNum,
<a name="l01893"></a>01893                          uint32_t address,
<a name="l01894"></a>01894                          uint8_t dataByte)
<a name="l01895"></a>01895 {
<a name="l01896"></a>01896     uint8_t  error;
<a name="l01897"></a>01897     uint32_t status;
<a name="l01898"></a>01898 
<a name="l01899"></a>01899     assert( pSd != NULL ) ;
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga0881e572c2c166e60e7f050546277405">CARD_TYPE_bmSDIO</a>) {
<a name="l01902"></a>01902         status = dataByte;
<a name="l01903"></a>01903         error = Cmd52(pSd, 1, functionNum, 0, address, &amp;status);
<a name="l01904"></a>01904         <span class="keywordflow">if</span> (error) {
<a name="l01905"></a>01905             TRACE_ERROR(<span class="stringliteral">&quot;SDIO_WrDirect.Cmd52: %u\n\r&quot;</span>, error);
<a name="l01906"></a>01906             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01907"></a>01907         }
<a name="l01908"></a>01908         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; STATUS_SDIO_R5) {
<a name="l01909"></a>01909             TRACE_ERROR(<span class="stringliteral">&quot;WR_DIRECT(%u) st %x\n\r&quot;</span>,
<a name="l01910"></a>01910                 address, status);
<a name="l01911"></a>01911             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01912"></a>01912         }
<a name="l01913"></a>01913     }
<a name="l01914"></a>01914     <span class="keywordflow">else</span> {
<a name="l01915"></a>01915         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01916"></a>01916     }
<a name="l01917"></a>01917     <span class="keywordflow">return</span> 0;
<a name="l01918"></a>01918 }
<a name="l01919"></a>01919 <span class="comment"></span>
<a name="l01920"></a>01920 <span class="comment">/**</span>
<a name="l01921"></a>01921 <span class="comment"> * Read byte by byte from SDIO card, using RW_EXTENDED command.</span>
<a name="l01922"></a>01922 <span class="comment"> * \param pSd            Pointer to SdCard instance.</span>
<a name="l01923"></a>01923 <span class="comment"> * \param functionNum    Function number.</span>
<a name="l01924"></a>01924 <span class="comment"> * \param address        First byte address of data in SDIO card.</span>
<a name="l01925"></a>01925 <span class="comment"> * \param isFixedAddress During transfer the data address is never increased.</span>
<a name="l01926"></a>01926 <span class="comment"> * \param pData          Pointer to data buffer.</span>
<a name="l01927"></a>01927 <span class="comment"> * \param size           Size of data to read (1 ~ 512).</span>
<a name="l01928"></a>01928 <span class="comment"> * \param fCallback      Callback function invoked when transfer finished.</span>
<a name="l01929"></a>01929 <span class="comment"> * \param pArg           Pointer to callback argument.</span>
<a name="l01930"></a>01930 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01931"></a>01931 <span class="comment"> */</span>
<a name="l01932"></a><a class="code" href="group__sdmmc__api.html#ga558dbbb5280eabf4c5299defaff360d0">01932</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga558dbbb5280eabf4c5299defaff360d0">SDIO_ReadBytes</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01933"></a>01933                        uint8_t functionNum,
<a name="l01934"></a>01934                        uint32_t address,
<a name="l01935"></a>01935                        uint8_t isFixedAddress,
<a name="l01936"></a>01936                        uint8_t *pData,
<a name="l01937"></a>01937                        uint16_t size,
<a name="l01938"></a>01938                        <a class="code" href="group__sdmmc__hal.html#gae854df62b67725efa2e97f8ea868abd2">SdmmcCallback</a> fCallback,
<a name="l01939"></a>01939                        <span class="keywordtype">void</span>* pArg)
<a name="l01940"></a>01940 {
<a name="l01941"></a>01941     uint8_t  error;
<a name="l01942"></a>01942     uint32_t status;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     assert( pSd != NULL ) ;
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga0881e572c2c166e60e7f050546277405">CARD_TYPE_bmSDIO</a>) {
<a name="l01947"></a>01947         <span class="keywordflow">if</span> (size == 0) <span class="keywordflow">return</span> SDMMC_ERROR_PARAM;
<a name="l01948"></a>01948         error = Cmd53(pSd,
<a name="l01949"></a>01949                       0, functionNum, 0, !isFixedAddress,
<a name="l01950"></a>01950                       address, pData, size,
<a name="l01951"></a>01951                       &amp;status,
<a name="l01952"></a>01952                       fCallback, pArg);
<a name="l01953"></a>01953         <span class="keywordflow">if</span> (error) {
<a name="l01954"></a>01954             TRACE_ERROR(<span class="stringliteral">&quot;IO_RdBytes.Cmd53: %u\n\r&quot;</span>, error);
<a name="l01955"></a>01955             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01956"></a>01956         }
<a name="l01957"></a>01957         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; STATUS_SDIO_R5) {
<a name="l01958"></a>01958             TRACE_ERROR(<span class="stringliteral">&quot;RD_EXT st %x\n\r&quot;</span>, status);
<a name="l01959"></a>01959             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l01960"></a>01960         }
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962     <span class="keywordflow">else</span> {
<a name="l01963"></a>01963         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l01964"></a>01964     }
<a name="l01965"></a>01965     <span class="keywordflow">return</span> 0;
<a name="l01966"></a>01966 }
<a name="l01967"></a>01967 <span class="comment"></span>
<a name="l01968"></a>01968 <span class="comment">/**</span>
<a name="l01969"></a>01969 <span class="comment"> * Write byte by byte to SDIO card, using RW_EXTENDED command.</span>
<a name="l01970"></a>01970 <span class="comment"> * \param pSd            Pointer to SdCard instance.</span>
<a name="l01971"></a>01971 <span class="comment"> * \param functionNum    Function number.</span>
<a name="l01972"></a>01972 <span class="comment"> * \param address        First byte address of data in SDIO card.</span>
<a name="l01973"></a>01973 <span class="comment"> * \param isFixedAddress During transfer the data address is never increased.</span>
<a name="l01974"></a>01974 <span class="comment"> * \param pData          Pointer to data buffer.</span>
<a name="l01975"></a>01975 <span class="comment"> * \param size           Size of data to write (1 ~ 512).</span>
<a name="l01976"></a>01976 <span class="comment"> * \param fCallback      Callback function invoked when transfer finished.</span>
<a name="l01977"></a>01977 <span class="comment"> * \param pArg           Pointer to callback argument.</span>
<a name="l01978"></a>01978 <span class="comment"> * \return 0 if successful; otherwise returns an \ref sdmmc_rc &quot;error code&quot;.</span>
<a name="l01979"></a>01979 <span class="comment"> */</span>
<a name="l01980"></a><a class="code" href="group__sdmmc__api.html#ga12e2b16f2281412dee5b95012779a471">01980</a> uint8_t <a class="code" href="group__sdmmc__mem__api.html#ga12e2b16f2281412dee5b95012779a471">SDIO_WriteBytes</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd,
<a name="l01981"></a>01981                         uint8_t functionNum,
<a name="l01982"></a>01982                         uint32_t address,
<a name="l01983"></a>01983                         uint8_t isFixedAddress,
<a name="l01984"></a>01984                         uint8_t *pData,
<a name="l01985"></a>01985                         uint16_t size,
<a name="l01986"></a>01986                         <a class="code" href="group__sdmmc__hal.html#gae854df62b67725efa2e97f8ea868abd2">SdmmcCallback</a> fCallback,
<a name="l01987"></a>01987                         <span class="keywordtype">void</span>* pArg)
<a name="l01988"></a>01988 {
<a name="l01989"></a>01989     uint8_t  error;
<a name="l01990"></a>01990     uint32_t status;
<a name="l01991"></a>01991 
<a name="l01992"></a>01992     assert( pSd != NULL ) ;
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga0881e572c2c166e60e7f050546277405">CARD_TYPE_bmSDIO</a>) {
<a name="l01995"></a>01995         <span class="keywordflow">if</span> (size == 0) <span class="keywordflow">return</span> SDMMC_ERROR_PARAM;
<a name="l01996"></a>01996         error = Cmd53(pSd,
<a name="l01997"></a>01997                       1, functionNum, 0, !isFixedAddress,
<a name="l01998"></a>01998                       address, pData, size,
<a name="l01999"></a>01999                       (uint32_t*)&amp;status,
<a name="l02000"></a>02000                       fCallback, pArg);
<a name="l02001"></a>02001         Delay(100);
<a name="l02002"></a>02002         <span class="keywordflow">if</span> (error) {
<a name="l02003"></a>02003             TRACE_ERROR(<span class="stringliteral">&quot;IO_WrBytes.Cmd53: %u\n\r&quot;</span>, error);
<a name="l02004"></a>02004             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l02005"></a>02005         }
<a name="l02006"></a>02006         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; STATUS_SDIO_R5) {
<a name="l02007"></a>02007             TRACE_ERROR(<span class="stringliteral">&quot;WR_EXT st %x\n\r&quot;</span>, status);
<a name="l02008"></a>02008             <span class="keywordflow">return</span> SDMMC_ERROR;
<a name="l02009"></a>02009         }
<a name="l02010"></a>02010     }
<a name="l02011"></a>02011     <span class="keywordflow">else</span> {
<a name="l02012"></a>02012         <span class="keywordflow">return</span> SDMMC_ERROR_NOT_SUPPORT;
<a name="l02013"></a>02013     }
<a name="l02014"></a>02014     <span class="keywordflow">return</span> 0;
<a name="l02015"></a>02015 }
<a name="l02016"></a>02016 
<a name="l02017"></a>02017 
<a name="l02018"></a>02018 <span class="comment"></span>
<a name="l02019"></a>02019 <span class="comment">/**</span>
<a name="l02020"></a>02020 <span class="comment"> * Display SDIO card informations (CIS, tuple ...)</span>
<a name="l02021"></a>02021 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l02022"></a>02022 <span class="comment"> */</span>
<a name="l02023"></a><a class="code" href="group__sdmmc__api.html#ga8283ff57ccd6c5feeca881933f385e6e">02023</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#ga8283ff57ccd6c5feeca881933f385e6e">SDIO_DisplayCardInformation</a>(<a class="code" href="struct_sd_card.html">SdCard</a> * pSd)
<a name="l02024"></a>02024 {
<a name="l02025"></a>02025     uint32_t tmp = 0, addrCIS = 0, addrManfID = 0, addrFunc0 = 0;
<a name="l02026"></a>02026     uint8_t *p = (uint8_t*)&amp;tmp;
<a name="l02027"></a>02027     uint8_t buf[8];
<a name="l02028"></a>02028 
<a name="l02029"></a>02029     <span class="keywordflow">switch</span>(pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a>)
<a name="l02030"></a>02030     {
<a name="l02031"></a>02031         <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__cardtype.html#gad914628e823c3363d6acda0eeab5475f">CARD_SDIO</a>:
<a name="l02032"></a>02032             TRACE_INFO(<span class="stringliteral">&quot;** SDIO ONLY card\n\r&quot;</span>);
<a name="l02033"></a>02033             <span class="keywordflow">break</span>;
<a name="l02034"></a>02034         <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__cardtype.html#ga5249813b4d083c79dc34ed48a8788a18">CARD_SDCOMBO</a>: <span class="keywordflow">case</span> <a class="code" href="group__sdmmc__cardtype.html#gac871c8b0d83c6c07000a3f4bf8aeb889">CARD_SDHCCOMBO</a>:
<a name="l02035"></a>02035             TRACE_INFO(<span class="stringliteral">&quot;** SDIO Combo card\n\r&quot;</span>);
<a name="l02036"></a>02036             <span class="keywordflow">break</span>;
<a name="l02037"></a>02037         <span class="keywordflow">default</span>:
<a name="l02038"></a>02038             TRACE_INFO(<span class="stringliteral">&quot;** NO SDIO\n\r&quot;</span>);
<a name="l02039"></a>02039             <span class="keywordflow">return</span>;
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041     <span class="comment">/* CCCR */</span>
<a name="l02042"></a>02042     TRACE_INFO(<span class="stringliteral">&quot;====== CCCR ======\n\r&quot;</span>);
<a name="l02043"></a>02043     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga2990859e092568b1accd916417178c6a">SDIO_CCCR_REG</a>, p, 1);
<a name="l02044"></a>02044     TRACE_INFO(<span class="stringliteral">&quot;.SDIO       %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga548b45fffd7e2c50e637ce6fc3815f66">SDIO_SDIO</a>) &gt;&gt; 4);
<a name="l02045"></a>02045     TRACE_INFO(<span class="stringliteral">&quot;.CCCR       %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga499b15da98779a9c70a4516230c3fe64">SDIO_CCCR</a>) &gt;&gt; 0);
<a name="l02046"></a>02046     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga53ec7366e23e4ad54c2d294c113fde95">SDIO_SD_REV_REG</a>, p, 1);
<a name="l02047"></a>02047     TRACE_INFO(<span class="stringliteral">&quot;.SD         %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga7a67de58d32a8be49e5abfa112f18232">SDIO_SD</a>) &gt;&gt; 0);
<a name="l02048"></a>02048     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga4774a14753beebf2041b4714ae85d505">SDIO_IOE_REG</a>, p, 1);
<a name="l02049"></a>02049     TRACE_INFO(<span class="stringliteral">&quot;.IOE        %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga24e224201a30ff2898366a462afbf9c5">SDIO_IOE</a>) &gt;&gt; 0);
<a name="l02050"></a>02050     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga1ec91e96eba6ca91697f47482a5b57a8">SDIO_IOR_REG</a>, p, 1);
<a name="l02051"></a>02051     TRACE_INFO(<span class="stringliteral">&quot;.IOR        %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga242f1e8bcb5f3889e31ca05028514eea">SDIO_IOR</a>) &gt;&gt; 0);
<a name="l02052"></a>02052     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gafdecfaa015225ae3295d56fc3bc69fda">SDIO_IEN_REG</a>, p, 1);
<a name="l02053"></a>02053     TRACE_INFO(<span class="stringliteral">&quot;.IEN        %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga5ea116ff7f95730364de7e477e1d3dec">SDIO_IEN</a>) &gt;&gt; 0);
<a name="l02054"></a>02054     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga0e30d5f0d370225a62fc1be4ce79f761">SDIO_INT_REG</a>, p, 1);
<a name="l02055"></a>02055     TRACE_INFO(<span class="stringliteral">&quot;.INT        %02X\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga9456a573e6219e1413ddeb1ab0897b37">SDIO_INT</a>) &gt;&gt; 0);
<a name="l02056"></a>02056     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gad405973afe48dd8d9e22c6c1066e890e">SDIO_BUS_CTRL_REG</a>, p, 1);
<a name="l02057"></a>02057     TRACE_INFO(<span class="stringliteral">&quot;.CD         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga68b0ba389a4e3fdd1e867fcfe3e6d738">SDIO_CD</a>) &gt;&gt; 7);
<a name="l02058"></a>02058     TRACE_INFO(<span class="stringliteral">&quot;.SCSI       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gaccaf1336193982175bc4d51af27d6ef0">SDIO_SCSI</a>) &gt;&gt; 6);
<a name="l02059"></a>02059     TRACE_INFO(<span class="stringliteral">&quot;.ECSI       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gaa9902959910a85fd8085548b35df5618">SDIO_ECSI</a>) &gt;&gt; 5);
<a name="l02060"></a>02060     TRACE_INFO(<span class="stringliteral">&quot;.BUS_WIDTH  %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga8473d8007e71dd5337d695d7b9d4e3d5">SDIO_BUSWIDTH</a>) &gt;&gt; 0);
<a name="l02061"></a>02061     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gaddb10abe63f94e3253a4a20883d3afd7">SDIO_CAP_REG</a>, p, 1);
<a name="l02062"></a>02062     TRACE_INFO(<span class="stringliteral">&quot;.4BLS       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga96538b0ad2c63823d554ca56c673245d">SDIO_4BLS</a>) &gt;&gt; 7);
<a name="l02063"></a>02063     TRACE_INFO(<span class="stringliteral">&quot;.LSC        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga5ec5778ff9d1fa852adf9a8fb309295a">SDIO_LSC</a>) &gt;&gt; 6);
<a name="l02064"></a>02064     TRACE_INFO(<span class="stringliteral">&quot;.E4MI       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga9acab8a782a3cbe15c229aebeac95c97">SDIO_E4MI</a>) &gt;&gt; 5);
<a name="l02065"></a>02065     TRACE_INFO(<span class="stringliteral">&quot;.S4MI       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga58f4b1d81125d0092e6acffcb5efc271">SDIO_S4MI</a>) &gt;&gt; 4);
<a name="l02066"></a>02066     TRACE_INFO(<span class="stringliteral">&quot;.SBS        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gac2453dcde694a7d9a39cd44121fe7f01">SDIO_SBS</a>) &gt;&gt; 3);
<a name="l02067"></a>02067     TRACE_INFO(<span class="stringliteral">&quot;.SRW        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga33208b831a8a3bb64d00ceac5df7892a">SDIO_SRW</a>) &gt;&gt; 2);
<a name="l02068"></a>02068     TRACE_INFO(<span class="stringliteral">&quot;.SMB        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gad1d1e73c2f7a659727caa92cd5a8738d">SDIO_SMB</a>) &gt;&gt; 1);
<a name="l02069"></a>02069     TRACE_INFO(<span class="stringliteral">&quot;.SDC        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga367b677ef623541ba735397de5040561">SDIO_SDC</a>) &gt;&gt; 0);
<a name="l02070"></a>02070     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gaa05cd13e0dd708ab28d17e657e462c8e">SDIO_CIS_PTR_REG</a>, p, 3);
<a name="l02071"></a>02071     TRACE_INFO(<span class="stringliteral">&quot;.CIS_PTR    %06X\n\r&quot;</span>, tmp);
<a name="l02072"></a>02072     addrCIS = tmp; tmp = 0;
<a name="l02073"></a>02073     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga7113872210c97212a876d3e9aaaa2c6e">SDIO_BUS_SUSP_REG</a>, p, 1);
<a name="l02074"></a>02074     TRACE_INFO(<span class="stringliteral">&quot;.BR         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gac050f0a4476f13a34a3adcdcbb05a8df">SDIO_BR</a>) &gt;&gt; 1);
<a name="l02075"></a>02075     TRACE_INFO(<span class="stringliteral">&quot;.BS         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gabb5247786804c92dbadfb0e144566f94">SDIO_BS</a>) &gt;&gt; 0);
<a name="l02076"></a>02076     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gac29873c93eff4724ff32b6a0378f6107">SDIO_FUN_SEL_REG</a>, p, 1);
<a name="l02077"></a>02077     TRACE_INFO(<span class="stringliteral">&quot;.DF         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga08026d62191ceef40bfaa117e7ea3fb9">SDIO_DF</a>) &gt;&gt; 7);
<a name="l02078"></a>02078     TRACE_INFO(<span class="stringliteral">&quot;.FS         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gaaf2fbd019174bca7f64d2fcb0d40866c">SDIO_FS</a>) &gt;&gt; 0);
<a name="l02079"></a>02079     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga925a3de2f7a4008161988575bb6f36da">SDIO_EXEC_REG</a>, p, 1);
<a name="l02080"></a>02080     TRACE_INFO(<span class="stringliteral">&quot;.EX         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gabc8e3fa469acf9cc75b07dc1ba182401">SDIO_EX</a>));
<a name="l02081"></a>02081     TRACE_INFO(<span class="stringliteral">&quot;.EXM        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga2f9e3d49b47d04e281723bfd649aa34a">SDIO_EXM</a>) &gt;&gt; 0);
<a name="l02082"></a>02082     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gae0c8fd493fb41f68cb49296959f987ab">SDIO_READY_REG</a>, p, 1);
<a name="l02083"></a>02083     TRACE_INFO(<span class="stringliteral">&quot;.RF         %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#gab04759b168723011d405bf8da12db4c1">SDIO_RF</a>));
<a name="l02084"></a>02084     TRACE_INFO(<span class="stringliteral">&quot;.RFM        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga57104f3ad3072c33139ac6304dc1077e">SDIO_RFM</a>) &gt;&gt; 0);
<a name="l02085"></a>02085     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#ga123fee133b128b5eda75758f5017ea12">SDIO_FN0_BLKSIZ_REG</a>, p, 2);
<a name="l02086"></a>02086     TRACE_INFO(<span class="stringliteral">&quot;.FN0_SIZE   %d(%04X)\n\r&quot;</span>, tmp, tmp);
<a name="l02087"></a>02087     tmp = 0;
<a name="l02088"></a>02088     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gae7e71cd667e6418e6cb28c82f84f4ed8">SDIO_POWER_REG</a>, p, 1);
<a name="l02089"></a>02089     TRACE_INFO(<span class="stringliteral">&quot;.EMPC       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga6688e79b95685f8c320ac05d87cb561a">SDIO_EMPC</a>) &gt;&gt; 1);
<a name="l02090"></a>02090     TRACE_INFO(<span class="stringliteral">&quot;.SMPC       %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga783c1592b4cd4cac8208a6fb6cf67af2">SDIO_SMPC</a>) &gt;&gt; 0);
<a name="l02091"></a>02091     <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, <a class="code" href="group__sdio__cccr__def.html#gabacbfdd6b4d6f286af09cd8a15d0d6ff">SDIO_HS_REG</a>, p, 1);
<a name="l02092"></a>02092     TRACE_INFO(<span class="stringliteral">&quot;.EHS        %x\n\r&quot;</span>, (tmp &amp; <a class="code" href="group__sdio__cccr__def.html#ga6c78ba330227b8fd273068b90d4d1138">SDIO_EHS</a>) &gt;&gt; 1);
<a name="l02093"></a>02093     TRACE_INFO(<span class="stringliteral">&quot;.SHS        %x\n\r&quot;</span>, (tmp &amp; SDIO_SHS) &gt;&gt; 0);
<a name="l02094"></a>02094     <span class="comment">/* Metaformat */</span>
<a name="l02095"></a>02095     SdioFindTuples(pSd, addrCIS, 128, &amp;addrManfID, &amp;addrFunc0);
<a name="l02096"></a>02096     <span class="keywordflow">if</span> (addrManfID != 0) {
<a name="l02097"></a>02097         <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, addrManfID, buf, 6);
<a name="l02098"></a>02098         TRACE_INFO(<span class="stringliteral">&quot;==== CISTPL_MANFID ====\n\r&quot;</span>);
<a name="l02099"></a>02099         TRACE_INFO(<span class="stringliteral">&quot;._MANF %04X\n\r&quot;</span>, buf[2] + (buf[3] &lt;&lt; 8));
<a name="l02100"></a>02100         TRACE_INFO(<span class="stringliteral">&quot;._CARD %04X\n\r&quot;</span>, buf[4] + (buf[5] &lt;&lt; 8));
<a name="l02101"></a>02101     }
<a name="l02102"></a>02102     <span class="keywordflow">if</span> (addrFunc0 != 0) {
<a name="l02103"></a>02103         <a class="code" href="group__sdmmc__mem__api.html#ga2bbfca74b03b6074f472e9e410ac9a0b">SDIO_ReadDirect</a>(pSd, <a class="code" href="group__sdio__fun__def.html#gaf3dce40bc3851f971e202b9cfafb31a1">SDIO_CIA</a>, addrFunc0, buf, 6);
<a name="l02104"></a>02104         TRACE_INFO(<span class="stringliteral">&quot;== CISTPL_FUNCE Fun0 ==\n\r&quot;</span>);
<a name="l02105"></a>02105         TRACE_INFO(<span class="stringliteral">&quot;._FN0_BLK_SIZE   %d(0x%04X)\n\r&quot;</span>,
<a name="l02106"></a>02106             buf[3] + (buf[4] &lt;&lt; 8), buf[3] + (buf[4] &lt;&lt; 8));
<a name="l02107"></a>02107         TRACE_INFO(<span class="stringliteral">&quot;._MAX_TRAN_SPEED %02X\n\r&quot;</span>, buf[5]);
<a name="l02108"></a>02108     }
<a name="l02109"></a>02109 }
<a name="l02110"></a>02110 <span class="comment"></span>
<a name="l02111"></a>02111 <span class="comment">/**</span>
<a name="l02112"></a>02112 <span class="comment"> * Display the content of the CID register</span>
<a name="l02113"></a>02113 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l02114"></a>02114 <span class="comment"> */</span>
<a name="l02115"></a><a class="code" href="group__sdmmc__api.html#ga3a74f4b65cdf88b4ba395d599d6f4a55">02115</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#ga3a74f4b65cdf88b4ba395d599d6f4a55">SD_DisplayRegisterCID</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l02116"></a>02116 {
<a name="l02117"></a>02117     TRACE_INFO(<span class="stringliteral">&quot;======= CID =======\n\r&quot;</span>);
<a name="l02118"></a>02118     TRACE_INFO(<span class="stringliteral">&quot; .MID Manufacturer ID       %02X\n\r&quot;</span>,
<a name="l02119"></a>02119         <a class="code" href="group__sdmmc__mem__api.html#gaef9d2560ee0e4db89a55e9f6ad4bac80" title="Manufacturer ID.">SD_CID_MID</a>(pSd));
<a name="l02120"></a>02120 
<a name="l02121"></a>02121     TRACE_INFO(<span class="stringliteral">&quot; .CBX Card/BGA              %X\n\r&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga46f6506aef9390dbbe9b63f3515c1620" title="Card/BGA(eMMC).">SD_CID_CBX</a>(pSd));
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     TRACE_INFO(<span class="stringliteral">&quot; .OID OEM/Application ID    %c%c\n\r&quot;</span>,
<a name="l02124"></a>02124         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#ga0e9c72fcba4e05e8e35a4d1bfd4c3688" title="OEM/Application ID byte 1.">SD_CID_OID_BYTE_1</a>(pSd),
<a name="l02125"></a>02125         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#ga171e879f6cd14f44cb40740ce689b245" title="OEM/Application ID byte 0.">SD_CID_OID_BYTE_0</a>(pSd));
<a name="l02126"></a>02126 
<a name="l02127"></a>02127     TRACE_INFO(<span class="stringliteral">&quot; .PNM Product revision      %c%c%c%c%c\n\r&quot;</span>,
<a name="l02128"></a>02128         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#ga8e3897e2d411e249a7755a220dc11370" title="Product revision byte 4.">SD_CID_PNM_BYTE_4</a>(pSd),
<a name="l02129"></a>02129         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#ga9174483b043638a79c4458c84181c93b" title="Product revision byte 3.">SD_CID_PNM_BYTE_3</a>(pSd),
<a name="l02130"></a>02130         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#gace14e093ffdaa790b1b678b46695ebb2" title="Product revision byte 2.">SD_CID_PNM_BYTE_2</a>(pSd),
<a name="l02131"></a>02131         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#ga72d509a5cfb1ad85ae659dadd222ca30" title="Product revision byte 1.">SD_CID_PNM_BYTE_1</a>(pSd),
<a name="l02132"></a>02132         (<span class="keywordtype">char</span>)<a class="code" href="group__sdmmc__mem__api.html#gaffe29aa4f46a9ae7ce2314158f3f54e2" title="Product revision byte 0.">SD_CID_PNM_BYTE_0</a>(pSd));
<a name="l02133"></a>02133 
<a name="l02134"></a>02134     TRACE_INFO(<span class="stringliteral">&quot; .PRV Product serial number %02X%04X\n\r&quot;</span>,
<a name="l02135"></a>02135          <a class="code" href="group__sdmmc__mem__api.html#ga6b1c254dcc2cd4d49958528da115a8f2" title="Product serial number 2.">SD_CID_PRV_2</a>(pSd),
<a name="l02136"></a>02136          <a class="code" href="group__sdmmc__mem__api.html#gad7ac13a576704e5b39452b3737013d3f" title="Product serial number 1.">SD_CID_PRV_1</a>(pSd));
<a name="l02137"></a>02137 
<a name="l02138"></a>02138     TRACE_INFO(<span class="stringliteral">&quot; .MDT Manufacturing date    %04d/%02d\n\r&quot;</span>,
<a name="l02139"></a>02139         (uint16_t)<a class="code" href="group__sdmmc__mem__api.html#ga71bcdc9f540a4fb8d15adf77b5382551" title="Manufacturing date year.">SD_CID_MDT_YEAR</a>(pSd),
<a name="l02140"></a>02140         (uint8_t)<a class="code" href="group__sdmmc__mem__api.html#gafadac45e783850e3ea633196e0a85663" title="Manufacturing date month.">SD_CID_MDT_MONTH</a>(pSd));
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     TRACE_INFO(<span class="stringliteral">&quot; .CRC checksum              %02X\n\r&quot;</span>,
<a name="l02143"></a>02143          <a class="code" href="group__sdmmc__mem__api.html#ga85db56b3f15e7b18dae76f1517554b9d" title="CRC7 checksum.">SD_CID_CRC</a>(pSd));
<a name="l02144"></a>02144 }
<a name="l02145"></a>02145 <span class="comment"></span>
<a name="l02146"></a>02146 <span class="comment">/**</span>
<a name="l02147"></a>02147 <span class="comment"> * Display the content of the CSD register</span>
<a name="l02148"></a>02148 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l02149"></a>02149 <span class="comment"> */</span>
<a name="l02150"></a><a class="code" href="group__sdmmc__api.html#ga6bb2c5e3cb079a197dd433f1eb599eab">02150</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#ga6bb2c5e3cb079a197dd433f1eb599eab">SD_DisplayRegisterCSD</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l02151"></a>02151 {
<a name="l02152"></a>02152     TRACE_INFO(<span class="stringliteral">&quot;======== CSD ========&quot;</span>);
<a name="l02153"></a>02153     TRACE_INFO_WP(<span class="stringliteral">&quot;\n\r&quot;</span>);
<a name="l02154"></a>02154     TRACE_INFO(<span class="stringliteral">&quot; .CSD_STRUCTURE      0x%x\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gad82fdd0c4e9da984885df36992db6612" title="CSD structure 00b Version 1.0 01b version 2.0 High Cap.">SD_CSD_STRUCTURE</a>(pSd));
<a name="l02155"></a>02155     TRACE_INFO(<span class="stringliteral">&quot; .SPEC_VERS          0x%x\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gab86f2c60972ec452125b484d22bc6a35" title="System Specification Version Number.">SD_CSD_SPEC_VERS</a>(pSd));
<a name="l02156"></a>02156     TRACE_INFO(<span class="stringliteral">&quot; .TAAC               0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaedee3f6c036b1d521a95f552be6cfbce" title="Data read-access-time-1.">SD_CSD_TAAC</a>(pSd)              );
<a name="l02157"></a>02157     TRACE_INFO(<span class="stringliteral">&quot; .NSAC               0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga5eea8bf2609330eeba0a9fa0cbcbddff" title="Data read access-time-2 in CLK cycles.">SD_CSD_NSAC</a>(pSd)              );
<a name="l02158"></a>02158     TRACE_INFO(<span class="stringliteral">&quot; .TRAN_SPEED         0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga9ba1a5be408418ae43af9d5ba580bac8" title="Max. data transfer rate.">SD_CSD_TRAN_SPEED</a>(pSd)        );
<a name="l02159"></a>02159     TRACE_INFO(<span class="stringliteral">&quot; .CCC                0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gac4737ebbe55c736751f60a052e30c2dc" title="Card command class.">SD_CSD_CCC</a>(pSd)               );
<a name="l02160"></a>02160     TRACE_INFO(<span class="stringliteral">&quot; .READ_BL_LEN        0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga2874ee1435eb04b52f8e86032b8676d3" title="Max. read data block length.">SD_CSD_READ_BL_LEN</a>(pSd)       );
<a name="l02161"></a>02161     TRACE_INFO(<span class="stringliteral">&quot; .READ_BL_PARTIAL    0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaa14033802cef59b0f89e82236aa79717" title="Bartial blocks for read allowed.">SD_CSD_READ_BL_PARTIAL</a>(pSd)   );
<a name="l02162"></a>02162     TRACE_INFO(<span class="stringliteral">&quot; .WRITE_BLK_MISALIGN 0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gac01439d27963c693fa29fc184b374d97" title="Write block misalignment.">SD_CSD_WRITE_BLK_MISALIGN</a>(pSd));
<a name="l02163"></a>02163     TRACE_INFO(<span class="stringliteral">&quot; .READ_BLK_MISALIGN  0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gab7cb57ebeac3b92e3d161a62af6c0edb" title="Read block misalignment.">SD_CSD_READ_BLK_MISALIGN</a>(pSd) );
<a name="l02164"></a>02164     TRACE_INFO(<span class="stringliteral">&quot; .DSR_IMP            0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gae0fa8e7cc1b27d4266dabe7ab75579c2" title="DSP implemented.">SD_CSD_DSR_IMP</a>(pSd)           );
<a name="l02165"></a>02165     TRACE_INFO(<span class="stringliteral">&quot; .C_SIZE             0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga2edf758ebc74506c8e2b2fee49e031fe" title="Device size.">SD_CSD_C_SIZE</a>(pSd)            );
<a name="l02166"></a>02166     TRACE_INFO(<span class="stringliteral">&quot; .C_SIZE_HC          0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaa9cc983e80300fbde916deae4e886711" title="Device size v2.0 High Capacity.">SD_CSD_C_SIZE_HC</a>(pSd)         );
<a name="l02167"></a>02167     TRACE_INFO(<span class="stringliteral">&quot; .VDD_R_CURR_MIN     0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gad60f8cd004030ac9feffa0ae67c5e2e5" title="Max. read current VDD min.">SD_CSD_VDD_R_CURR_MIN</a>(pSd)    );
<a name="l02168"></a>02168     TRACE_INFO(<span class="stringliteral">&quot; .VDD_R_CURR_MAX     0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaf69626d33e5fc45b7bfb684be99f45f9" title="Max. read current VDD max.">SD_CSD_VDD_R_CURR_MAX</a>(pSd)    );
<a name="l02169"></a>02169     TRACE_INFO(<span class="stringliteral">&quot; .VDD_W_CURR_MIN     0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gab6f4279453d07a4385678df839953621" title="Max. write current VDD min.">SD_CSD_VDD_W_CURR_MIN</a>(pSd)    );
<a name="l02170"></a>02170     TRACE_INFO(<span class="stringliteral">&quot; .VDD_W_CURR_MAX     0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga2e0da40e802ad2daa9f377cef41223c4" title="Max. write current VDD max.">SD_CSD_VDD_W_CURR_MAX</a>(pSd)    );
<a name="l02171"></a>02171     TRACE_INFO(<span class="stringliteral">&quot; .C_SIZE_MULT        0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gab8d5ca2a04677eebfac7639e147936d9" title="Device size multiplier.">SD_CSD_C_SIZE_MULT</a>(pSd)       );
<a name="l02172"></a>02172     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_BLK_EN       0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gad49ccbec29ee94a3e3b6a71a9a82263e" title="Erase single block enable.">SD_CSD_ERASE_BLK_EN</a>(pSd)      );
<a name="l02173"></a>02173     TRACE_INFO(<span class="stringliteral">&quot; .SECTOR_SIZE        0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga0ab61611b852ba7d0e78de54af7e4ba4" title="Erase sector size.">SD_CSD_SECTOR_SIZE</a>(pSd)       );
<a name="l02174"></a>02174     TRACE_INFO(<span class="stringliteral">&quot; .WP_GRP_SIZE        0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga28ae58764af8f4380db740172cc55303" title="Write protect group size.">SD_CSD_WP_GRP_SIZE</a>(pSd)       );
<a name="l02175"></a>02175     TRACE_INFO(<span class="stringliteral">&quot; .WP_GRP_ENABLE      0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga41a1003dd62d9ef7428083385f028bd5" title="write protect group enable">SD_CSD_WP_GRP_ENABLE</a>(pSd)     );
<a name="l02176"></a>02176     TRACE_INFO(<span class="stringliteral">&quot; .R2W_FACTOR         0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga64ebf620177c7c4cdd007e28de3f6fc8" title="Write speed factor.">SD_CSD_R2W_FACTOR</a>(pSd)        );
<a name="l02177"></a>02177     TRACE_INFO(<span class="stringliteral">&quot; .WRITE_BL_LEN       0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga01628ba6d2a429bd5a3897fb2100ee99" title="Max write block length.">SD_CSD_WRITE_BL_LEN</a>(pSd)      );
<a name="l02178"></a>02178     TRACE_INFO(<span class="stringliteral">&quot; .WRITE_BL_PARTIAL   0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaecac84c8928772ffdf7a7004151d8f3b" title="Partial blocks for write allowed.">SD_CSD_WRITE_BL_PARTIAL</a>(pSd)  );
<a name="l02179"></a>02179     TRACE_INFO(<span class="stringliteral">&quot; .FILE_FORMAT_GRP    0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gaff2ce89224a73a1b7d4bf16d4339fe11" title="File format group.">SD_CSD_FILE_FORMAT_GRP</a>(pSd)   );
<a name="l02180"></a>02180     TRACE_INFO(<span class="stringliteral">&quot; .COPY               0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga7d4957285112c7802b26063d53bcbaa4" title="Copy flag (OTP).">SD_CSD_COPY</a>(pSd)              );
<a name="l02181"></a>02181     TRACE_INFO(<span class="stringliteral">&quot; .PERM_WRITE_PROTECT 0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga93011d1a504a17de35a43c73dcbcec25" title="Permanent write protect.">SD_CSD_PERM_WRITE_PROTECT</a>(pSd));
<a name="l02182"></a>02182     TRACE_INFO(<span class="stringliteral">&quot; .TMP_WRITE_PROTECT  0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gad191aeb93a0b67d98873778125e5603f" title="Temporary write protection.">SD_CSD_TMP_WRITE_PROTECT</a>(pSd) );
<a name="l02183"></a>02183     TRACE_INFO(<span class="stringliteral">&quot; .FILE_FORMAT        0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#ga275903677a1742e1bdd5a4acb8cddf17" title="File format.">SD_CSD_FILE_FORMAT</a>(pSd)       );
<a name="l02184"></a>02184     TRACE_INFO(<span class="stringliteral">&quot; .ECC                0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gab7ff337876b98bd920fba04b553399bf" title="CRC.">SD_CSD_ECC</a>(pSd)               );
<a name="l02185"></a>02185     TRACE_INFO(<span class="stringliteral">&quot; .CRC                0x%X\r\n&quot;</span>, <a class="code" href="group__sdmmc__mem__api.html#gac9d8802750405e07ede40830842f3db1" title="CRC.">SD_CSD_CRC</a>(pSd)               );
<a name="l02186"></a>02186     TRACE_INFO(<span class="stringliteral">&quot; .MULT               0x%X\r\n&quot;</span>, SD_CSD_MULT(pSd)              );
<a name="l02187"></a>02187     TRACE_INFO(<span class="stringliteral">&quot; .BLOCKNR            0x%X\r\n&quot;</span>, SD_CSD_BLOCKNR(pSd)           );
<a name="l02188"></a>02188     TRACE_INFO(<span class="stringliteral">&quot; .BLOCKNR_HC         0x%X\r\n&quot;</span>, SD_CSD_BLOCKNR_HC(pSd)        );
<a name="l02189"></a>02189     TRACE_INFO(<span class="stringliteral">&quot; .BLOCK_LEN          0x%X\r\n&quot;</span>, SD_CSD_BLOCK_LEN(pSd)         );
<a name="l02190"></a>02190     TRACE_INFO(<span class="stringliteral">&quot; .TOTAL_SIZE         0x%X\r\n&quot;</span>, SD_CSD_TOTAL_SIZE(pSd)        );
<a name="l02191"></a>02191     TRACE_INFO(<span class="stringliteral">&quot; .TOTAL_SIZE_HC      0x%X\r\n&quot;</span>, SD_CSD_TOTAL_SIZE_HC(pSd)     );
<a name="l02192"></a>02192     TRACE_INFO(<span class="stringliteral">&quot; -SD_TOTAL_SIZE      0x%X\r\n&quot;</span>, SD_TOTAL_SIZE(pSd)            );
<a name="l02193"></a>02193     TRACE_INFO(<span class="stringliteral">&quot; -SD_TOTAL_BLOCK     0x%X\r\n&quot;</span>, SD_TOTAL_BLOCK(pSd)           );
<a name="l02194"></a>02194 }
<a name="l02195"></a>02195 <span class="comment"></span>
<a name="l02196"></a>02196 <span class="comment">/**</span>
<a name="l02197"></a>02197 <span class="comment"> * Display the content of the EXT_CSD register</span>
<a name="l02198"></a>02198 <span class="comment"> * \param pSd Pointer to SdCard instance.</span>
<a name="l02199"></a>02199 <span class="comment"> */</span>
<a name="l02200"></a><a class="code" href="group__sdmmc__api.html#ga1123268e5759a415d05bf54e5ad729f5">02200</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#ga1123268e5759a415d05bf54e5ad729f5">SD_DisplayRegisterECSD</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l02201"></a>02201 {
<a name="l02202"></a>02202     <span class="keywordflow">if</span> ((pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &amp; <a class="code" href="group__sdmmc__cardtype.html#ga42594c45fac98a62b012ec3641bac8e5">CARD_TYPE_bmSDMMC</a>) == <a class="code" href="group__sdmmc__cardtype.html#ga1df56d102459c52ef22d4e4f2d0abaef">CARD_MMC</a>
<a name="l02203"></a>02203         &amp;&amp; <a class="code" href="group__sdmmc__api.html#ga07bc6ff131eea07308e69fcaa30213cf">MMC_IsVer4</a>(pSd)
<a name="l02204"></a>02204         &amp;&amp; <a class="code" href="group__sdmmc__mem__api.html#gad82fdd0c4e9da984885df36992db6612" title="CSD structure 00b Version 1.0 01b version 2.0 High Cap.">SD_CSD_STRUCTURE</a>(pSd) &gt;= 2) {}
<a name="l02205"></a>02205     <span class="keywordflow">else</span> {
<a name="l02206"></a>02206         TRACE_INFO(<span class="stringliteral">&quot;** EXT_CSD NOT SUPPORTED\n\r&quot;</span>);
<a name="l02207"></a>02207         <span class="keywordflow">return</span>;
<a name="l02208"></a>02208     }
<a name="l02209"></a>02209     TRACE_INFO(<span class="stringliteral">&quot;======= EXT_CSD =======&quot;</span>);
<a name="l02210"></a>02210     TRACE_INFO_WP(<span class="stringliteral">&quot;\n\r&quot;</span>);
<a name="l02211"></a>02211     TRACE_INFO(<span class="stringliteral">&quot; .S_CMD_SET            : 0x%X\n\r&quot;</span>,
<a name="l02212"></a>02212         SD_EXTCSD_S_CMD_SET(pSd));
<a name="l02213"></a>02213     TRACE_INFO(<span class="stringliteral">&quot; .BOOT_INFO            : 0x%X\n\r&quot;</span>,
<a name="l02214"></a>02214         SD_EXTCSD_BOOT_INFO(pSd));
<a name="l02215"></a>02215     TRACE_INFO(<span class="stringliteral">&quot; .BOOT_SIZE_MULTI      : 0x%X\n\r&quot;</span>,
<a name="l02216"></a>02216         SD_EXTCSD_BOOT_SIZE_MULTI(pSd));
<a name="l02217"></a>02217     TRACE_INFO(<span class="stringliteral">&quot; .ACC_SIZE             : 0x%X\n\r&quot;</span>,
<a name="l02218"></a>02218         SD_EXTCSD_ACC_SIZE(pSd));
<a name="l02219"></a>02219     TRACE_INFO(<span class="stringliteral">&quot; .HC_ERASE_GRP_SIZE    : 0x%X\n\r&quot;</span>,
<a name="l02220"></a>02220         SD_EXTCSD_HC_ERASE_GRP_SIZE(pSd));
<a name="l02221"></a>02221     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_TIMEOUT_MULT   : 0x%X\n\r&quot;</span>,
<a name="l02222"></a>02222         SD_EXTCSD_ERASE_TIMEOUT_MULT(pSd));
<a name="l02223"></a>02223     TRACE_INFO(<span class="stringliteral">&quot; .REL_WR_SEC_C         : 0x%X\n\r&quot;</span>,
<a name="l02224"></a>02224         SD_EXTCSD_REL_WR_SEC_C(pSd));
<a name="l02225"></a>02225     TRACE_INFO(<span class="stringliteral">&quot; .HC_WP_GRP_SIZE       : 0x%X\n\r&quot;</span>,
<a name="l02226"></a>02226         SD_EXTCSD_HC_WP_GRP_SIZE(pSd));
<a name="l02227"></a>02227     TRACE_INFO(<span class="stringliteral">&quot; .S_C_VCC              : 0x%X\n\r&quot;</span>,
<a name="l02228"></a>02228         SD_EXTCSD_S_C_VCC(pSd));
<a name="l02229"></a>02229     TRACE_INFO(<span class="stringliteral">&quot; .S_C_VCCQ             : 0x%X\n\r&quot;</span>,
<a name="l02230"></a>02230         SD_EXTCSD_S_C_VCCQ(pSd));
<a name="l02231"></a>02231     TRACE_INFO(<span class="stringliteral">&quot; .S_A_TIMEOUT          : 0x%X\n\r&quot;</span>,
<a name="l02232"></a>02232         SD_EXTCSD_S_A_TIMEOUT(pSd));
<a name="l02233"></a>02233     TRACE_INFO(<span class="stringliteral">&quot; .SEC_COUNT            : 0x%X\n\r&quot;</span>,
<a name="l02234"></a>02234         SD_EXTCSD_SEC_COUNT(pSd));
<a name="l02235"></a>02235     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_W_8_52      : 0x%X\n\r&quot;</span>,
<a name="l02236"></a>02236         SD_EXTCSD_MIN_PERF_W_8_52(pSd));
<a name="l02237"></a>02237     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_R_8_52      : 0x%X\n\r&quot;</span>,
<a name="l02238"></a>02238         SD_EXTCSD_MIN_PERF_R_8_52(pSd));
<a name="l02239"></a>02239     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_W_8_26_4_52 : 0x%X\n\r&quot;</span>,
<a name="l02240"></a>02240         SD_EXTCSD_MIN_PERF_W_8_26_4_52(pSd));
<a name="l02241"></a>02241     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_R_8_26_4_52 : 0x%X\n\r&quot;</span>,
<a name="l02242"></a>02242         SD_EXTCSD_MIN_PERF_R_8_26_4_52(pSd));
<a name="l02243"></a>02243     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_W_4_26      : 0x%X\n\r&quot;</span>,
<a name="l02244"></a>02244         SD_EXTCSD_MIN_PERF_W_4_26(pSd));
<a name="l02245"></a>02245     TRACE_INFO(<span class="stringliteral">&quot; .MIN_PERF_R_4_26      : 0x%X\n\r&quot;</span>,
<a name="l02246"></a>02246         SD_EXTCSD_MIN_PERF_R_4_26(pSd));
<a name="l02247"></a>02247     TRACE_INFO(<span class="stringliteral">&quot; .PWR_CL_26_360        : 0x%X\n\r&quot;</span>,
<a name="l02248"></a>02248         SD_EXTCSD_PWR_CL_26_360(pSd));
<a name="l02249"></a>02249     TRACE_INFO(<span class="stringliteral">&quot; .PWR_CL_52_360        : 0x%X\n\r&quot;</span>,
<a name="l02250"></a>02250         SD_EXTCSD_PWR_CL_52_360(pSd));
<a name="l02251"></a>02251     TRACE_INFO(<span class="stringliteral">&quot; .PWR_CL_26_195        : 0x%X\n\r&quot;</span>,
<a name="l02252"></a>02252         SD_EXTCSD_PWR_CL_26_195(pSd));
<a name="l02253"></a>02253     TRACE_INFO(<span class="stringliteral">&quot; .PWR_CL_52_195        : 0x%X\n\r&quot;</span>,
<a name="l02254"></a>02254         SD_EXTCSD_PWR_CL_52_195(pSd));
<a name="l02255"></a>02255     TRACE_INFO(<span class="stringliteral">&quot; .CARD_TYPE            : 0x%X\n\r&quot;</span>,
<a name="l02256"></a>02256         SD_EXTCSD_CARD_TYPE(pSd));
<a name="l02257"></a>02257     TRACE_INFO(<span class="stringliteral">&quot; .CSD_STRUCTURE        : 0x%X\n\r&quot;</span>,
<a name="l02258"></a>02258         SD_EXTCSD_CSD_STRUCTURE(pSd));
<a name="l02259"></a>02259     TRACE_INFO(<span class="stringliteral">&quot; .EXT_CSD_REV          : 0x%X\n\r&quot;</span>,
<a name="l02260"></a>02260         SD_EXTCSD_EXT_CSD_REV(pSd));
<a name="l02261"></a>02261     TRACE_INFO(<span class="stringliteral">&quot; .CMD_SET              : 0x%X\n\r&quot;</span>,
<a name="l02262"></a>02262         SD_EXTCSD_CMD_SET(pSd));
<a name="l02263"></a>02263     TRACE_INFO(<span class="stringliteral">&quot; .CMD_SET_REV          : 0x%X\n\r&quot;</span>,
<a name="l02264"></a>02264         SD_EXTCSD_CMD_SET_REV(pSd));
<a name="l02265"></a>02265     TRACE_INFO(<span class="stringliteral">&quot; .POWER_CLASS          : 0x%X\n\r&quot;</span>,
<a name="l02266"></a>02266         SD_EXTCSD_POWER_CLASS(pSd));
<a name="l02267"></a>02267     TRACE_INFO(<span class="stringliteral">&quot; .HS_TIMING            : 0x%X\n\r&quot;</span>,
<a name="l02268"></a>02268         SD_EXTCSD_HS_TIMING(pSd));
<a name="l02269"></a>02269     TRACE_INFO(<span class="stringliteral">&quot; .BUS_WIDTH            : 0x%X\n\r&quot;</span>,
<a name="l02270"></a>02270         SD_EXTCSD_BUS_WIDTH(pSd));
<a name="l02271"></a>02271     TRACE_INFO(<span class="stringliteral">&quot; .ERASED_MEM_CONT      : 0x%X\n\r&quot;</span>,
<a name="l02272"></a>02272         SD_EXTCSD_ERASED_MEM_CONT(pSd));
<a name="l02273"></a>02273     TRACE_INFO(<span class="stringliteral">&quot; .BOOT_CONFIG          : 0x%X\n\r&quot;</span>,
<a name="l02274"></a>02274         SD_EXTCSD_BOOT_CONFIG(pSd));
<a name="l02275"></a>02275     TRACE_INFO(<span class="stringliteral">&quot; .BOOT_BUS_WIDTH       : 0x%X\n\r&quot;</span>,
<a name="l02276"></a>02276         SD_EXTCSD_BOOT_BUS_WIDTH(pSd));
<a name="l02277"></a>02277     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_GROUP_DEF      : 0x%X\n\r&quot;</span>,
<a name="l02278"></a>02278         SD_EXTCSD_ERASE_GROUP_DEF(pSd));
<a name="l02279"></a>02279 }
<a name="l02280"></a>02280 <span class="comment"></span>
<a name="l02281"></a>02281 <span class="comment">/**</span>
<a name="l02282"></a>02282 <span class="comment"> * Display the content of the SCR register</span>
<a name="l02283"></a>02283 <span class="comment"> * \param pSd  Pointer to SdCard instance.</span>
<a name="l02284"></a>02284 <span class="comment"> */</span>
<a name="l02285"></a><a class="code" href="group__sdmmc__api.html#ga8c37d8671871cbc6820e5500bfac4a2e">02285</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#ga8c37d8671871cbc6820e5500bfac4a2e">SD_DisplayRegisterSCR</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l02286"></a>02286 {
<a name="l02287"></a>02287     <span class="keywordflow">if</span> (pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &gt;= <a class="code" href="group__sdmmc__cardtype.html#ga5f88e605935067b9dccd47b5ab2994e8">CARD_SD</a> &amp;&amp; pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &lt;= <a class="code" href="group__sdmmc__cardtype.html#ga08ec437adcd4a70a6d4804dfa3171086">CARD_SDHC</a>) {}
<a name="l02288"></a>02288     <span class="keywordflow">else</span> {
<a name="l02289"></a>02289         TRACE_INFO(<span class="stringliteral">&quot;** SCR NOT Supported!\n\r&quot;</span>);
<a name="l02290"></a>02290         <span class="keywordflow">return</span>;
<a name="l02291"></a>02291     }
<a name="l02292"></a>02292     TRACE_INFO(<span class="stringliteral">&quot;========== SCR ==========&quot;</span>);
<a name="l02293"></a>02293     TRACE_INFO_WP(<span class="stringliteral">&quot;\n\r&quot;</span>);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     TRACE_INFO(<span class="stringliteral">&quot; .SCR_STRUCTURE         :0x%X\n\r&quot;</span>,
<a name="l02296"></a>02296         SD_SCR_SCR_STRUCTURE(pSd));
<a name="l02297"></a>02297     TRACE_INFO(<span class="stringliteral">&quot; .SD_SPEC               :0x%X\n\r&quot;</span>,
<a name="l02298"></a>02298         SD_SCR_SD_SPEC(pSd));
<a name="l02299"></a>02299     TRACE_INFO(<span class="stringliteral">&quot; .DATA_STAT_AFTER_ERASE :0x%X\n\r&quot;</span>,
<a name="l02300"></a>02300         SD_SCR_DATA_STAT_AFTER_ERASE(pSd));
<a name="l02301"></a>02301     TRACE_INFO(<span class="stringliteral">&quot; .SD_SECURITY           :0x%X\n\r&quot;</span>,
<a name="l02302"></a>02302         SD_SCR_SD_SECURITY(pSd));
<a name="l02303"></a>02303     TRACE_INFO(<span class="stringliteral">&quot; .SD_BUS_WIDTHS         :0x%X\n\r&quot;</span>,
<a name="l02304"></a>02304         SD_SCR_SD_BUS_WIDTHS(pSd));
<a name="l02305"></a>02305 }
<a name="l02306"></a>02306 <span class="comment"></span>
<a name="l02307"></a>02307 <span class="comment">/**</span>
<a name="l02308"></a>02308 <span class="comment"> * Display the content of the SD Status</span>
<a name="l02309"></a>02309 <span class="comment"> * \param pSd  Pointer to SdCard instance.</span>
<a name="l02310"></a>02310 <span class="comment"> */</span>
<a name="l02311"></a><a class="code" href="group__sdmmc__api.html#gab0c01cf3a32e9fc25402ecaf5e03b559">02311</a> <span class="keywordtype">void</span> <a class="code" href="group__sdmmc__mem__api.html#gab0c01cf3a32e9fc25402ecaf5e03b559">SD_DisplaySdStatus</a>(<a class="code" href="struct_sd_card.html">SdCard</a> *pSd)
<a name="l02312"></a>02312 {
<a name="l02313"></a>02313     <span class="keywordflow">if</span> (   pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &gt;= <a class="code" href="group__sdmmc__cardtype.html#ga5f88e605935067b9dccd47b5ab2994e8">CARD_SD</a>
<a name="l02314"></a>02314         &amp;&amp; pSd-&gt;<a class="code" href="struct_sd_card.html#a61fc1a1505de0b1be17cf4ae98b704fe">cardType</a> &lt;= <a class="code" href="group__sdmmc__cardtype.html#ga08ec437adcd4a70a6d4804dfa3171086">CARD_SDHC</a>
<a name="l02315"></a>02315         &amp;&amp; (pSd-&gt;<a class="code" href="struct_sd_card.html#aab58ab224ab7bcdd88f4623105816546">optCmdBitMap</a> &amp; SD_ACMD13_SUPPORT) ) {}
<a name="l02316"></a>02316     <span class="keywordflow">else</span> {
<a name="l02317"></a>02317         TRACE_INFO(<span class="stringliteral">&quot;** SD Status NOT Supported!\n\r&quot;</span>);
<a name="l02318"></a>02318         <span class="keywordflow">return</span>;
<a name="l02319"></a>02319     }
<a name="l02320"></a>02320     TRACE_INFO(<span class="stringliteral">&quot;=========== STAT ============&quot;</span>);
<a name="l02321"></a>02321     TRACE_INFO_WP(<span class="stringliteral">&quot;\n\r&quot;</span>);
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     TRACE_INFO(<span class="stringliteral">&quot; .DAT_BUS_WIDTH          :0x%X\n\r&quot;</span>,
<a name="l02324"></a>02324         <a class="code" href="group__sdmmc__mem__api.html#ga386cd25ae4ab7828ed8fa84e983cfac4">SD_STAT_DAT_BUS_WIDTH</a>(pSd));
<a name="l02325"></a>02325     TRACE_INFO(<span class="stringliteral">&quot; .SECURED_MODE           :0x%X\n\r&quot;</span>,
<a name="l02326"></a>02326         <a class="code" href="group__sdmmc__mem__api.html#gaf571604da9aa952a45145986cd48ae7c" title="Secured Mode.">SD_STAT_SECURED_MODE</a>(pSd));
<a name="l02327"></a>02327     TRACE_INFO(<span class="stringliteral">&quot; .SD_CARD_TYPE           :0x%X\n\r&quot;</span>,
<a name="l02328"></a>02328         <a class="code" href="group__sdmmc__mem__api.html#ga7a298ced8795d19db254e2b4508eaff6" title="SD Memory Cards as defined in 1.01~2.00.">SD_STAT_SD_CARD_TYPE</a>(pSd));
<a name="l02329"></a>02329     TRACE_INFO(<span class="stringliteral">&quot; .SIZE_OF_PROTECTED_AREA :0x%X\n\r&quot;</span>,
<a name="l02330"></a>02330         <a class="code" href="group__sdmmc__mem__api.html#ga12fc4da7569c5cb81b46b2443d2376c6" title="STD: ThisSize*Multi*BlockLen, HC: Size in bytes.">SD_STAT_SIZE_OF_PROTECTED_AREA</a>(pSd));
<a name="l02331"></a>02331     TRACE_INFO(<span class="stringliteral">&quot; .SPEED_CLASS            :0x%X\n\r&quot;</span>,
<a name="l02332"></a>02332         <a class="code" href="group__sdmmc__mem__api.html#ga6d3c3425bc97d6de6d214ffada22293b" title="Speed Class, value can be calculated by Pw/2.">SD_STAT_SPEED_CLASS</a>(pSd));
<a name="l02333"></a>02333     TRACE_INFO(<span class="stringliteral">&quot; .PERFORMANCE_MOVE       :0x%X\n\r&quot;</span>,
<a name="l02334"></a>02334         <a class="code" href="group__sdmmc__mem__api.html#gabf2c0b79ad6ab964817aadd9894f951f" title="8-bit, by 1MB/s step.">SD_STAT_PERFORMANCE_MOVE</a>(pSd));
<a name="l02335"></a>02335     TRACE_INFO(<span class="stringliteral">&quot; .AU_SIZE                :0x%X\n\r&quot;</span>,
<a name="l02336"></a>02336         <a class="code" href="group__sdmmc__mem__api.html#ga3c10e7f94a78ffa47edd25c96fcf9799" title="AU Size, in power of 2 from 16KB.">SD_STAT_AU_SIZE</a>(pSd));
<a name="l02337"></a>02337     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_SIZE             :0x%X\n\r&quot;</span>,
<a name="l02338"></a>02338         <a class="code" href="group__sdmmc__mem__api.html#gaddb258349842d68fab6232aed57cabdc" title="16-bit, number of AUs erased.">SD_STAT_ERASE_SIZE</a>(pSd));
<a name="l02339"></a>02339     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_TIMEOUT          :0x%X\n\r&quot;</span>,
<a name="l02340"></a>02340         SD_STAT_ERASE_TIMEOUT(pSd));
<a name="l02341"></a>02341     TRACE_INFO(<span class="stringliteral">&quot; .ERASE_OFFSET           :0x%X\n\r&quot;</span>,
<a name="l02342"></a>02342         SD_STAT_ERASE_OFFSET(pSd));
<a name="l02343"></a>02343 }<span class="comment"></span>
<a name="l02344"></a>02344 <span class="comment">/**@}*/</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
